<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Fruit Slice WebGL</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bangers&display=swap');
        /* ç‚ºäº†æ”¯æ´ä¸­æ–‡é¡¯ç¤ºï¼Œå¢åŠ å¾®è»Ÿæ­£é»‘é«”æˆ– Noto Sans TC */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Bangers', 'Noto Sans TC', sans-serif; /* åŠ å…¥ä¸­æ–‡å­—é«” */
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ° Canvas */
            text-shadow: 2px 2px 0 #000;
        }

        /* HUD */
        .hud-element {
            position: absolute;
            color: white;
            font-size: 2rem;
            padding: 20px;
        }

        #score-display {
            top: 10px;
            left: 20px;
            color: #ffd700;
            font-size: 1.5rem;
        }

        #best-score-display {
            top: 50px;
            left: 20px;
            font-size: 1.2rem;
            color: #aaa;
        }

        #lives-display {
            top: 10px;
            right: 20px;
            text-align: right;
            font-size: 1.5rem;
        }

        #lives-icons {
            color: #ff4444;
            letter-spacing: 5px;
        }

        #timer-display {
            top: 10px;
            width: 100%;
            text-align: center;
            font-size: 4rem;
            display: none; /* é è¨­éš±è— */
            color: #fff;
        }

        #combo-display {
            position: absolute;
            top: 20%;
            left: 10%;
            font-size: 4rem;
            color: #00ffcc;
            transform: rotate(-15deg);
            opacity: 0;
            transition: opacity 0.3s, transform 0.2s;
            font-family: 'Bangers', cursive; /* Combo ä¿æŒè‹±æ–‡é¢¨æ ¼ */
        }

        /* Menu Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85); /* èƒŒæ™¯ç¨å¾®èª¿æš—ä¸€é»ä»¥å‡¸é¡¯æ–‡å­— */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto; /* å…è¨±é»æ“Šé¸å–® */
            z-index: 20;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 4rem;
            color: #ff6b6b;
            margin-bottom: 10px;
            margin-top: 0;
            background: -webkit-linear-gradient(#eee, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(4px 4px 0px #000);
            text-align: center;
            line-height: 1.2;
        }

        .menu-btn {
            font-family: 'Bangers', 'Noto Sans TC', sans-serif;
            font-size: 1.8rem;
            padding: 15px 40px;
            margin: 10px;
            width: 280px; /* å›ºå®šæŒ‰éˆ•å¯¬åº¦ */
            background: linear-gradient(45deg, #ff9966, #ff5e62);
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 50px; /* åœ“è§’æ›´åœ“æ½¤ */
            transition: transform 0.1s, filter 0.1s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            text-shadow: 1px 1px 0 #000;
        }

        .menu-btn:hover {
            transform: scale(1.05);
            filter: brightness(1.2);
        }

        .menu-btn:active {
            transform: scale(0.95);
        }

        .mode-desc {
            color: #ccc;
            font-family: 'Noto Sans TC', sans-serif;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        #game-over-title {
            color: #ff4444;
        }
        
        /* æ–°å¢ï¼šéŠæˆ²èªªæ˜å€å¡Šæ¨£å¼ */
        .instruction-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px 30px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-top: 20px;
            max-width: 600px;
            color: #ddd;
            font-family: 'Noto Sans TC', sans-serif;
            text-align: left;
            line-height: 1.6;
            font-size: 1rem;
        }
        
        .instruction-box h3 {
            color: #ffd700;
            margin: 0 0 10px 0;
            text-align: center;
            font-size: 1.3rem;
        }
        
        .instruction-box ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .instruction-box li {
            margin-bottom: 5px;
        }
        
        .highlight {
            color: #ff6b6b;
            font-weight: bold;
        }

    </style>
    <!-- Import Three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="score-display">åˆ†æ•¸: <span id="score-val">0</span></div>
        <div id="best-score-display">æœ€é«˜åˆ†: <span id="best-val">0</span></div>
        <div id="lives-display">ç”Ÿå‘½å€¼<br><span id="lives-icons">XXX</span></div>
        <div id="timer-display">60</div>
        <div id="combo-display">COMBO x3</div>
    </div>

    <!-- Main Menu -->
    <div id="start-screen" class="screen">
        <h1>SLICE MASTER 3D<br><span style="font-size: 2rem; color: #fff;">(æ°´æœå¿è€… 3Dç‰ˆ)</span></h1>
        <p class="mode-desc">è«‹é¸æ“‡éŠæˆ²æ¨¡å¼</p>
        
        <button class="menu-btn" onclick="gameApp.startGame('classic')">ç¶“å…¸æ¨¡å¼ (Classic)</button>
        <button class="menu-btn" onclick="gameApp.startGame('time')">è¨ˆæ™‚æ¨¡å¼ (Time Attack)</button>
        <button class="menu-btn" onclick="gameApp.startGame('arcade')">è¡—æ©Ÿç‹‚æ­¡ (Arcade)</button>
        
        <!-- æ–°å¢ï¼šéŠæˆ²èªªæ˜å€å¡Š -->
        <div class="instruction-box">
            <h3>ğŸ® éŠæˆ²ç©æ³•èªªæ˜</h3>
            <ul>
                <li><strong>åŸºæœ¬æ“ä½œï¼š</strong>æŒ‰ä½æ»‘é¼ å·¦éµï¼ˆæˆ–æ‰‹æŒ‡ï¼‰åœ¨è¢å¹•ä¸Šæ‹–æ›³ï¼Œç”¢ç”Ÿåˆ€å…‰ä¾†åˆ‡å‰²æ°´æœã€‚</li>
                <li><strong>å¾—åˆ†æŠ€å·§ï¼š</strong>ä¸€æ¬¡åˆ‡ä¸­å¤šå€‹æ°´æœå¯ç²å¾— <span class="highlight">Combo é€£æ“ŠåŠ åˆ†</span>ï¼</li>
                <li><strong>âš ï¸ æ³¨æ„äº‹é …ï¼š</strong>åƒè¬ä¸è¦åˆ‡åˆ° <span class="highlight">é»‘è‰²ç‚¸å½ˆ</span>ï¼</li>
                <li><strong>æ¨¡å¼ä»‹ç´¹ï¼š</strong>
                    <ul>
                        <li>ç¶“å…¸ï¼šåˆ‡åˆ°ç‚¸å½ˆæ‰£ç”Ÿå‘½ï¼Œæ¼æ¥æ°´æœä¹Ÿæ‰£ç”Ÿå‘½ã€‚</li>
                        <li>è¨ˆæ™‚ï¼šé™æ™‚ 60 ç§’ï¼Œåˆ‡ç‚¸å½ˆåªæ‰£åˆ†ï¼Œçˆ­å–æœ€é«˜åˆ†ã€‚</li>
                        <li>è¡—æ©Ÿï¼šå¤§é‡æ°´æœï¼Œç„¡ç”Ÿå‘½é™åˆ¶ï¼Œç›¡æƒ…äº«å—åˆ‡å‰²å¿«æ„Ÿï¼</li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden">
        <h1 id="game-over-title">éŠæˆ²çµæŸ</h1>
        <h2 style="color:white; font-size: 3rem;">æœ€çµ‚åˆ†æ•¸: <span id="final-score">0</span></h2>
        <button class="menu-btn" onclick="gameApp.restartGame()">å†ç©ä¸€æ¬¡</button>
        <button class="menu-btn" onclick="gameApp.showMenu()">å›ä¸»é¸å–®</button>
    </div>

<script type="module">
import * as THREE from 'three';

/**
 * ------------------------------------------------------------------
 * Audio System (Synthesizer)
 * Generates sounds on the fly using Web Audio API to avoid external assets
 * ------------------------------------------------------------------
 */
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3; // Volume
        this.masterGain.connect(this.ctx.destination);
        this.enabled = true;
    }

    playSlice() {
        if (!this.enabled) return;
        this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        // White noise approximation for "swoosh" is hard with just osc, 
        // so we use a high freq sine sweep
        osc.frequency.setValueAtTime(800 + Math.random() * 400, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);
        osc.type = 'triangle';
        
        gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);

        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.2);
    }

    playSquish() {
        if (!this.enabled) return;
        // Squishy sound
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(300 + Math.random() * 100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.8, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
    }

    playThrow() {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(200, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(400, this.ctx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
    }

    playExplosion() {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.5);
        gain.gain.setValueAtTime(1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.6);
    }

    playCombo() {
        if (!this.enabled) return;
        const now = this.ctx.currentTime;
        const notes = [523.25, 659.25, 783.99, 1046.50]; // C Major arpeggio
        notes.forEach((freq, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sine';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.1, now + i * 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.05 + 0.3);
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start(now + i * 0.05);
            osc.stop(now + i * 0.05 + 0.35);
        });
    }
}

/**
 * ------------------------------------------------------------------
 * Visual Effect Classes (Particles & Trails)
 * ------------------------------------------------------------------
 */

class Trail {
    constructor(scene) {
        this.scene = scene;
        this.maxPoints = 20;
        this.points = [];
        // Create a tube-like trail using a ribbon (Mesh) is better than Line
        // But for performance and simplicity in vanilla ThreeJS without MeshLine,
        // we use a wide chaotic line or simpler: distinct glowing sprites.
        // Let's use a connected Line loop for the core.
        
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(this.maxPoints * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.LineBasicMaterial({ 
            color: 0xffffff, 
            linewidth: 3, // Note: WebGL linewidth is limited to 1 on Windows usually
            transparent: true,
            opacity: 0.8
        });

        this.mesh = new THREE.Line(geometry, material);
        this.mesh.frustumCulled = false;
        this.scene.add(this.mesh);
    }

    update(mousePos, isDown) {
        if (isDown) {
            this.points.push(mousePos.clone());
            if (this.points.length > this.maxPoints) {
                this.points.shift();
            }
        } else {
            // Fade out trail quickly when mouse released
            if (this.points.length > 0) this.points.shift();
            if (this.points.length > 0) this.points.shift();
        }

        const positions = this.mesh.geometry.attributes.position.array;
        let index = 0;
        
        // Fill positions
        for (let i = 0; i < this.points.length; i++) {
            positions[index++] = this.points[i].x;
            positions[index++] = this.points[i].y;
            positions[index++] = this.points[i].z;
        }
        // Collapse remaining points to the last valid point
        const lastPoint = this.points.length > 0 ? this.points[this.points.length-1] : new THREE.Vector3(0,0,0);
        while(index < positions.length) {
            positions[index++] = lastPoint.x;
            positions[index++] = lastPoint.y;
            positions[index++] = lastPoint.z;
        }
        
        this.mesh.geometry.attributes.position.needsUpdate = true;
        
        // Dynamic color based on speed? Optional.
    }
}

class ParticleSystem {
    constructor(scene) {
        this.scene = scene;
        this.particles = [];
        // Reuse geometries to save memory
        this.geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
    }

    emit(position, color, count = 10, speed = 1) {
        const mat = new THREE.MeshPhongMaterial({ color: color, shininess: 100 });
        
        for(let i=0; i<count; i++) {
            const mesh = new THREE.Mesh(this.geo, mat);
            mesh.position.copy(position);
            // Random explosion velocity
            mesh.userData = {
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * speed,
                    (Math.random() - 0.5) * speed,
                    (Math.random() - 0.5) * speed
                ),
                life: 1.0 + Math.random() * 0.5,
                rotSpeed: new THREE.Vector3(Math.random(), Math.random(), Math.random())
            };
            this.scene.add(mesh);
            this.particles.push(mesh);
        }
    }

    update(dt) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.position.add(p.userData.velocity);
            p.rotation.x += p.userData.rotSpeed.x * 0.1;
            p.rotation.y += p.userData.rotSpeed.y * 0.1;
            p.userData.velocity.y -= 9.8 * dt * 0.5; // Gravity
            p.userData.life -= dt;
            p.scale.setScalar(p.userData.life); // Shrink

            if (p.userData.life <= 0) {
                this.scene.remove(p);
                this.particles.splice(i, 1);
                p.geometry.dispose(); // Clean up if not shared
                // Note: Material disposal logic simplified for demo
            }
        }
    }
}

/**
 * ------------------------------------------------------------------
 * Game Object Classes (Fruits & Bombs)
 * ------------------------------------------------------------------
 */

class GameObject {
    constructor(type, scene) {
        this.type = type; // 'watermelon', 'apple', 'bomb', etc.
        this.scene = scene;
        this.active = true;
        this.sliced = false;
        this.group = new THREE.Group();
        
        // Physics properties
        this.velocity = new THREE.Vector3(0, 0, 0);
        this.rotationAxis = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize();
        this.rotationSpeed = Math.random() * 2 + 1;

        this.createModel();
        this.scene.add(this.group);
    }

    createModel() {
        // Build the "Whole" mesh and the "Sliced" meshes
        this.wholeMesh = new THREE.Group();
        this.slicedMesh1 = new THREE.Group(); // Left half
        this.slicedMesh2 = new THREE.Group(); // Right half

        let mainColor, interiorColor, geometry;

        switch(this.type) {
            case 'watermelon':
                mainColor = 0x2e8b57; // SeaGreen
                interiorColor = 0xff6347; // Tomato
                geometry = new THREE.SphereGeometry(1, 16, 16);
                // Add stripes texture logic simplified: just color
                break;
            case 'apple':
                mainColor = 0xff0000;
                interiorColor = 0xffffe0;
                geometry = new THREE.SphereGeometry(0.7, 16, 16);
                break;
            case 'banana':
                mainColor = 0xffd700;
                interiorColor = 0xffffe0;
                // Curved shape approx
                geometry = new THREE.CapsuleGeometry(0.4, 1.2, 4, 8);
                break;
            case 'pineapple':
                mainColor = 0xffa500;
                interiorColor = 0xffff00;
                geometry = new THREE.CylinderGeometry(0.6, 0.6, 1.5, 8);
                break;
            case 'bomb':
                mainColor = 0x111111;
                geometry = new THREE.SphereGeometry(1, 16, 16);
                break;
            default: // kiwi
                mainColor = 0x8b4513;
                interiorColor = 0x90ee90;
                geometry = new THREE.SphereGeometry(0.6, 16, 16);
        }

        if (this.type === 'bomb') {
            // Bomb Setup
            const mat = new THREE.MeshPhongMaterial({ color: mainColor, shininess: 100 });
            const mesh = new THREE.Mesh(geometry, mat);
            this.wholeMesh.add(mesh);
            
            // Fuse / Red light
            const wickGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5);
            const wickMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const wick = new THREE.Mesh(wickGeo, wickMat);
            wick.position.y = 1;
            this.wholeMesh.add(wick);

            // Glowing core
            this.glowMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const light = new THREE.PointLight(0xff0000, 1, 3);
            this.wholeMesh.add(light);
            
            this.isBomb = true;
        } else {
            // Fruit Setup
            const mat = new THREE.MeshPhongMaterial({ color: mainColor });
            const whole = new THREE.Mesh(geometry, mat);
            this.wholeMesh.add(whole);
            this.isBomb = false;

            // Create two halves for sliced state
            // Trick: We create two identical meshes but clipped or just shifted?
            // Easier for this scope: Two smaller, closed meshes representing halves
            // Or use scale to flatten? 
            // Let's just clone the geometry and rotate/offset them to look like halves.
            
            const innerMat = new THREE.MeshPhongMaterial({ color: interiorColor });
            
            // Half 1
            const h1 = new THREE.Mesh(geometry.clone(), mat);
            const c1 = new THREE.Mesh(new THREE.CircleGeometry(geometry.parameters.radius || 0.5, 16), innerMat);
            h1.scale.set(1, 1, 0.5); // Flatten
            h1.position.z = 0.25;
            c1.position.z = 0;
            c1.rotation.y = Math.PI;
            // Note: Proper CSG is too heavy. This is a "visual hack" for performance.
            this.slicedMesh1.add(h1);
            
            // Half 2
            const h2 = new THREE.Mesh(geometry.clone(), mat);
            h2.scale.set(1, 1, 0.5);
            h2.position.z = -0.25;
            this.slicedMesh2.add(h2);
            
            this.slicedMesh1.visible = false;
            this.slicedMesh2.visible = false;
            this.group.add(this.slicedMesh1);
            this.group.add(this.slicedMesh2);
            
            this.juiceColor = interiorColor;
        }

        this.group.add(this.wholeMesh);
    }

    update(dt) {
        if (!this.active) return;

        // Gravity
        this.velocity.y -= 15 * dt; // Gravity constant
        this.group.position.add(this.velocity.clone().multiplyScalar(dt));

        if (!this.sliced) {
            // Rotate whole fruit
            this.group.rotation.x += this.rotationAxis.x * this.rotationSpeed * dt;
            this.group.rotation.y += this.rotationAxis.y * this.rotationSpeed * dt;
            
            // Bomb pulse
            if (this.isBomb) {
                const s = 1 + Math.sin(Date.now() * 0.01) * 0.2;
                this.wholeMesh.scale.setScalar(s);
            }
        } else {
            // Move halves apart
            this.slicedMesh1.position.add(this.slicedVel1.clone().multiplyScalar(dt));
            this.slicedMesh1.rotation.z += 2 * dt;
            
            this.slicedMesh2.position.add(this.slicedVel2.clone().multiplyScalar(dt));
            this.slicedMesh2.rotation.z -= 2 * dt;
        }

        // Bounds check (fell off screen)
        if (this.group.position.y < -15) {
            this.active = false;
            this.scene.remove(this.group);
            return "missed";
        }
        return "active";
    }

    slice(directionVec) {
        if (this.sliced || this.isBomb) return;
        
        this.sliced = true;
        this.wholeMesh.visible = false;
        this.slicedMesh1.visible = true;
        this.slicedMesh2.visible = true;

        // Calculate split velocity based on slice direction (cross product logic approx)
        // Or just generic outward force
        const normal = new THREE.Vector3(directionVec.y, -directionVec.x, 0).normalize();
        
        this.slicedVel1 = new THREE.Vector3(normal.x, normal.y, 1).multiplyScalar(3);
        this.slicedVel2 = new THREE.Vector3(-normal.x, -normal.y, -1).multiplyScalar(3);
    }
}

/**
 * ------------------------------------------------------------------
 * Main Game Manager
 * ------------------------------------------------------------------
 */
class GameApp {
    constructor() {
        this.initThree();
        this.setupInput();
        
        this.audio = new SoundManager();
        this.particles = new ParticleSystem(this.scene);
        this.trail = new Trail(this.scene);

        this.objects = [];
        this.score = 0;
        this.lives = 3;
        this.bestScore = localStorage.getItem('fruitSliceBest') || 0;
        this.mode = 'menu'; // menu, playing, gameover
        this.gameTime = 0;
        this.spawnTimer = 0;
        this.spawnRate = 1.5; // seconds

        // State
        this.mouse = new THREE.Vector2();
        this.prevMouse = new THREE.Vector2();
        this.isMouseDown = false;
        this.raycaster = new THREE.Raycaster();
        this.mouseWorldPos = new THREE.Vector3();

        // Combo System
        this.comboCount = 0;
        this.comboTimer = 0;

        this.ui = {
            score: document.getElementById('score-val'),
            best: document.getElementById('best-val'),
            lives: document.getElementById('lives-icons'),
            timer: document.getElementById('timer-display'),
            combo: document.getElementById('combo-display'),
            startScreen: document.getElementById('start-screen'),
            gameOverScreen: document.getElementById('game-over-screen'),
            finalScore: document.getElementById('final-score')
        };

        this.updateUI();
        this.animate();
    }

    initThree() {
        this.container = document.getElementById('canvas-container');
        this.scene = new THREE.Scene();
        
        // Camera
        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        this.camera.position.set(0, 0, 18);
        this.camera.lookAt(0, 0, 0);

        // Renderer
        this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.container.appendChild(this.renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        this.scene.add(dirLight);

        // Background Element (Simple wood wall or gradient)
        // Let's keep it dark/simple per requirements.
    }

    setupInput() {
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });

        const onMove = (x, y) => {
            // Normalized Coordinates
            this.mouse.x = (x / window.innerWidth) * 2 - 1;
            this.mouse.y = -(y / window.innerHeight) * 2 + 1;

            // Project mouse to Z=0 plane for trail and physics
            this.mouseWorldPos.set(this.mouse.x, this.mouse.y, 0.5);
            this.mouseWorldPos.unproject(this.camera);
            const dir = this.mouseWorldPos.sub(this.camera.position).normalize();
            const distance = -this.camera.position.z / dir.z;
            this.mouseWorldPos = this.camera.position.clone().add(dir.multiplyScalar(distance));
        };

        document.addEventListener('mousemove', e => {
            onMove(e.clientX, e.clientY);
        });
        
        document.addEventListener('mousedown', () => {
            this.isMouseDown = true;
            this.audio.ctx.resume(); // Unlock audio context
        });
        document.addEventListener('mouseup', () => this.isMouseDown = false);

        // Touch support
        document.addEventListener('touchmove', e => {
            e.preventDefault();
            onMove(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        document.addEventListener('touchstart', (e) => {
            this.isMouseDown = true;
            this.audio.ctx.resume();
            onMove(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        document.addEventListener('touchend', () => this.isMouseDown = false);
    }

    startGame(mode) {
        this.mode = 'playing';
        this.gameModeType = mode;
        this.score = 0;
        this.lives = 3;
        this.gameTime = 0;
        this.spawnTimer = 0;
        this.comboCount = 0;
        
        // Clear old objects
        this.objects.forEach(obj => this.scene.remove(obj.group));
        this.objects = [];

        // Hide Menus
        this.ui.startScreen.classList.add('hidden');
        this.ui.gameOverScreen.classList.add('hidden');
        
        // Mode Specifics
        if (mode === 'time') {
            this.timeLeft = 60;
            this.ui.timer.style.display = 'block';
            this.ui.lives.style.display = 'none';
        } else if (mode === 'arcade') {
            this.timeLeft = 60;
            this.ui.timer.style.display = 'block';
            this.ui.lives.style.display = 'none';
            this.lives = 999;
        } else {
            // Classic
            this.ui.timer.style.display = 'none';
            this.ui.lives.style.display = 'block';
        }

        this.updateUI();
        this.audio.playThrow(); // Start sound
    }

    showMenu() {
        this.mode = 'menu';
        this.ui.startScreen.classList.remove('hidden');
        this.ui.gameOverScreen.classList.add('hidden');
    }

    restartGame() {
        this.startGame(this.gameModeType);
    }

    spawnObject() {
        const types = ['watermelon', 'apple', 'banana', 'pineapple', 'kiwi'];
        
        // Bomb chance logic
        let type = types[Math.floor(Math.random() * types.length)];
        const bombChance = this.gameModeType === 'arcade' ? 0.3 : 0.15;
        
        if (Math.random() < bombChance && this.gameTime > 2.0) { // No bombs in first 2 sec
            type = 'bomb';
        }

        const obj = new GameObject(type, this.scene);
        
        // Setup Toss Physics
        const xPos = (Math.random() - 0.5) * 10; // x range -5 to 5
        obj.group.position.set(xPos, -12, 0); // Start below screen
        
        // Throw towards center generally
        const xVel = -xPos * (0.2 + Math.random() * 0.3); 
        const yVel = 14 + Math.random() * 6; // Height
        
        obj.velocity.set(xVel, yVel, 0);
        
        this.objects.push(obj);
        this.audio.playThrow();
    }

    handleSlicing(dt) {
        if (!this.isMouseDown) {
            this.prevMouse.copy(this.mouseWorldPos);
            return;
        }

        // Calculate mouse velocity roughly
        const dist = this.mouseWorldPos.distanceTo(this.prevMouse);
        const speed = dist / dt;

        // Only slice if moving fast enough
        if (speed > 10) {
            // Line Segment-Sphere Intersection Simplified
            // Check distance from object to the line segment formed by prev -> curr mouse
            
            const line3 = new THREE.Line3(this.prevMouse, this.mouseWorldPos);
            const closestPoint = new THREE.Vector3();

            this.objects.forEach(obj => {
                if (obj.active && !obj.sliced) {
                    // Get object world position
                    line3.closestPointToPoint(obj.group.position, true, closestPoint);
                    const distanceToRay = closestPoint.distanceTo(obj.group.position);
                    
                    // Collision Radius approx 1.0
                    if (distanceToRay < 1.2) {
                        this.sliceObject(obj, this.mouseWorldPos.clone().sub(this.prevMouse).normalize());
                    }
                }
            });
        }

        this.prevMouse.copy(this.mouseWorldPos);
    }

    sliceObject(obj, direction) {
        if (obj.isBomb) {
            // Boom
            this.audio.playExplosion();
            this.particles.emit(obj.group.position, 0xff0000, 30, 5);
            this.handleBombHit();
            obj.active = false;
            this.scene.remove(obj.group);
        } else {
            // Fruit
            obj.slice(direction);
            this.audio.playSquish();
            this.particles.emit(obj.group.position, obj.juiceColor, 15, 3);
            
            // Score
            this.score++;
            
            // Combo Logic
            this.comboCount++;
            this.comboTimer = 0.5; // 0.5s window for combo
            
            if (this.comboCount > 1) {
                this.score += this.comboCount; // Bonus points
                this.audio.playCombo();
                this.showComboUI(this.comboCount);
            } else {
                this.audio.playSlice();
            }

            this.updateUI();
        }
    }

    handleBombHit() {
        // Flash screen
        this.renderer.domElement.style.filter = 'brightness(3) sepia(1) hue-rotate(-50deg)';
        setTimeout(() => {
            this.renderer.domElement.style.filter = 'none';
        }, 100);

        if (this.gameModeType === 'classic') {
            this.lives--;
            this.updateUI();
            if (this.lives <= 0) this.gameOver();
        } else if (this.gameModeType === 'time') {
            this.score = Math.max(0, this.score - 5);
            this.updateUI();
        } else {
            // Arcade - just penalty
            this.score = Math.max(0, this.score - 10);
            this.updateUI();
        }
    }

    showComboUI(count) {
        this.ui.combo.innerText = `COMBO x${count}`;
        this.ui.combo.style.opacity = 1;
        this.ui.combo.style.transform = 'rotate(-15deg) scale(1.5)';
        
        // Reset anim
        clearTimeout(this.comboAnimTimer);
        this.comboAnimTimer = setTimeout(() => {
            this.ui.combo.style.opacity = 0;
            this.ui.combo.style.transform = 'rotate(-15deg) scale(1)';
        }, 500);
    }

    gameOver() {
        this.mode = 'gameover';
        if (this.score > this.bestScore) {
            this.bestScore = this.score;
            localStorage.setItem('fruitSliceBest', this.bestScore);
        }
        this.ui.finalScore.innerText = this.score;
        this.ui.gameOverScreen.classList.remove('hidden');
        this.updateUI();
        this.audio.playExplosion(); // Sound effect for end
    }

    updateUI() {
        this.ui.score.innerText = this.score;
        this.ui.best.innerText = this.bestScore;
        
        // Lives logic
        let livesStr = '';
        for(let i=0; i<this.lives; i++) livesStr += 'X ';
        this.ui.lives.innerText = livesStr;
    }

    animate() {
        requestAnimationFrame(this.animate.bind(this));
        
        const dt = 0.016; // Fixed timestep approx
        
        // Render Trail
        this.trail.update(this.mouseWorldPos, this.isMouseDown && this.mode === 'playing');

        if (this.mode === 'playing') {
            this.gameTime += dt;
            this.spawnTimer -= dt;
            
            // Combo Timer Decay
            if (this.comboTimer > 0) {
                this.comboTimer -= dt;
                if (this.comboTimer <= 0) this.comboCount = 0;
            }

            // Spawner Logic
            if (this.spawnTimer <= 0) {
                // Difficulty progression
                let spawnCount = 1;
                if (this.gameTime > 10) spawnCount = Math.random() > 0.5 ? 2 : 1;
                if (this.gameTime > 30) spawnCount = Math.floor(Math.random() * 3) + 1;
                if (this.gameModeType === 'arcade') spawnCount += 2;

                for(let i=0; i<spawnCount; i++) {
                    this.spawnObject();
                }
                
                // Rate increases over time
                const difficultyMod = Math.max(0.5, 1.5 - (this.gameTime * 0.01));
                this.spawnRate = (this.gameModeType === 'arcade' ? 0.5 : 1.0) * difficultyMod;
                this.spawnTimer = this.spawnRate + Math.random() * 0.5;
            }

            // Timer Mode Logic
            if (this.gameModeType === 'time' || this.gameModeType === 'arcade') {
                this.timeLeft -= dt;
                this.ui.timer.innerText = Math.ceil(this.timeLeft);
                if (this.timeLeft <= 0) {
                    this.gameOver();
                }
            }

            // Slicing
            this.handleSlicing(dt);
            
            // Update Objects
            for (let i = this.objects.length - 1; i >= 0; i--) {
                const status = this.objects[i].update(dt);
                if (status === 'missed') {
                    if (!this.objects[i].isBomb && !this.objects[i].sliced && this.gameModeType === 'classic') {
                        // Lost a life for missing a fruit
                        this.lives--;
                        this.updateUI();
                        if (this.lives <= 0) {
                            this.gameOver();
                            break;
                        }
                    }
                    this.objects.splice(i, 1);
                } else if (!this.objects[i].active) {
                    this.objects.splice(i, 1); // Clean up sliced/exploded immediately from logic array, visual is handled
                }
            }
        }

        // Visual Updates
        this.particles.update(dt);
        this.renderer.render(this.scene, this.camera);
    }
}

// Init Game when DOM ready
window.gameApp = new GameApp();

</script>
</body>
</html>
