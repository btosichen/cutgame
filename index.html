<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>3D Fruit Slice WebGL</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bangers&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Bangers', 'Noto Sans TC', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            /* é—œéµä¿®æ­£ï¼šç¦æ­¢è§¸æ§æ²å‹•ï¼Œç¢ºä¿æ»‘å‹•åªç”¨æ–¼éŠæˆ² */
            touch-action: none; 
            overscroll-behavior: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            touch-action: none; /* é›™é‡ä¿éšª */
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            text-shadow: 2px 2px 0 #000;
        }

        /* HUD */
        .hud-element {
            position: absolute;
            color: white;
            font-size: 2rem;
            padding: 20px;
        }

        #score-display {
            top: 10px;
            left: 20px;
            color: #ffd700;
            font-size: 1.5rem;
        }

        #best-score-display {
            top: 50px;
            left: 20px;
            font-size: 1.2rem;
            color: #aaa;
        }

        #lives-display {
            top: 10px;
            right: 20px;
            text-align: right;
            font-size: 1.5rem;
        }

        #lives-icons {
            color: #ff4444;
            letter-spacing: 5px;
        }

        #timer-display {
            top: 10px;
            width: 100%;
            text-align: center;
            font-size: 4rem;
            display: none;
            color: #fff;
        }

        #combo-display {
            position: absolute;
            top: 20%;
            left: 10%;
            font-size: 4rem;
            color: #00ffcc;
            transform: rotate(-15deg);
            opacity: 0;
            transition: opacity 0.3s, transform 0.2s;
            font-family: 'Bangers', cursive;
        }

        /* Menu Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 20;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 4rem;
            color: #ff6b6b;
            margin-bottom: 10px;
            margin-top: 0;
            background: -webkit-linear-gradient(#eee, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(4px 4px 0px #000);
            text-align: center;
            line-height: 1.2;
        }

        .menu-btn {
            font-family: 'Bangers', 'Noto Sans TC', sans-serif;
            font-size: 1.8rem;
            padding: 15px 40px;
            margin: 10px;
            width: 280px;
            background: linear-gradient(45deg, #ff9966, #ff5e62);
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 50px;
            transition: transform 0.1s, filter 0.1s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            text-shadow: 1px 1px 0 #000;
        }

        .menu-btn:hover {
            transform: scale(1.05);
            filter: brightness(1.2);
        }

        .menu-btn:active {
            transform: scale(0.95);
        }

        .mode-desc {
            color: #ccc;
            font-family: 'Noto Sans TC', sans-serif;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        #game-over-title {
            color: #ff4444;
        }
        
        .instruction-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px 30px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-top: 20px;
            max-width: 600px;
            color: #ddd;
            font-family: 'Noto Sans TC', sans-serif;
            text-align: left;
            line-height: 1.6;
            font-size: 1rem;
        }
        
        .instruction-box h3 {
            color: #ffd700;
            margin: 0 0 10px 0;
            text-align: center;
            font-size: 1.3rem;
        }
        
        .instruction-box ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .instruction-box li {
            margin-bottom: 5px;
        }
        
        .highlight {
            color: #ff6b6b;
            font-weight: bold;
        }

    </style>
    <!-- Import Three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="score-display">åˆ†æ•¸: <span id="score-val">0</span></div>
        <div id="best-score-display">æœ€é«˜åˆ†: <span id="best-val">0</span></div>
        <div id="lives-display">ç”Ÿå‘½å€¼<br><span id="lives-icons">XXX</span></div>
        <div id="timer-display">60</div>
        <div id="combo-display">COMBO x3</div>
    </div>

    <!-- Main Menu -->
    <div id="start-screen" class="screen">
        <h1>SLICE MASTER 3D<br><span style="font-size: 2rem; color: #fff;">(æ°´æœå¿è€… 3Dç‰ˆ)</span></h1>
        <p class="mode-desc">è«‹é¸æ“‡éŠæˆ²æ¨¡å¼</p>
        
        <button class="menu-btn" onclick="gameApp.startGame('classic')">ç¶“å…¸æ¨¡å¼ (Classic)</button>
        <button class="menu-btn" onclick="gameApp.startGame('time')">è¨ˆæ™‚æ¨¡å¼ (Time Attack)</button>
        <button class="menu-btn" onclick="gameApp.startGame('arcade')">è¡—æ©Ÿç‹‚æ­¡ (Arcade)</button>
        
        <div class="instruction-box">
            <h3>ğŸ® éŠæˆ²ç©æ³•èªªæ˜</h3>
            <ul>
                <li><strong>åŸºæœ¬æ“ä½œï¼š</strong>æŒ‰ä½æ»‘é¼ å·¦éµï¼ˆæˆ–æ‰‹æŒ‡ï¼‰åœ¨è¢å¹•ä¸Šæ‹–æ›³ï¼Œç”¢ç”Ÿåˆ€å…‰ä¾†åˆ‡å‰²æ°´æœã€‚</li>
                <li><strong>å¾—åˆ†æŠ€å·§ï¼š</strong>ä¸€æ¬¡åˆ‡ä¸­å¤šå€‹æ°´æœå¯ç²å¾— <span class="highlight">Combo é€£æ“ŠåŠ åˆ†</span>ï¼</li>
                <li><strong>âš ï¸ æ³¨æ„äº‹é …ï¼š</strong>åƒè¬ä¸è¦åˆ‡åˆ° <span class="highlight">é»‘è‰²ç‚¸å½ˆ</span>ï¼</li>
            </ul>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden">
        <h1 id="game-over-title">éŠæˆ²çµæŸ</h1>
        <h2 style="color:white; font-size: 3rem;">æœ€çµ‚åˆ†æ•¸: <span id="final-score">0</span></h2>
        <button class="menu-btn" onclick="gameApp.restartGame()">å†ç©ä¸€æ¬¡</button>
        <button class="menu-btn" onclick="gameApp.showMenu()">å›ä¸»é¸å–®</button>
    </div>

<script type="module">
import * as THREE from 'three';

class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3;
        this.masterGain.connect(this.ctx.destination);
        this.enabled = true;
    }

    playSlice() {
        if (!this.enabled || this.ctx.state === 'suspended') return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(800 + Math.random() * 400, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);
        osc.type = 'triangle';
        
        gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);

        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.2);
    }

    playSquish() {
        if (!this.enabled || this.ctx.state === 'suspended') return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(300 + Math.random() * 100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.8, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
    }

    playThrow() {
        if (!this.enabled || this.ctx.state === 'suspended') return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(200, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(400, this.ctx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
    }

    playExplosion() {
        if (!this.enabled || this.ctx.state === 'suspended') return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.5);
        gain.gain.setValueAtTime(1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.6);
    }

    playCombo() {
        if (!this.enabled || this.ctx.state === 'suspended') return;
        const now = this.ctx.currentTime;
        const notes = [523.25, 659.25, 783.99, 1046.50]; 
        notes.forEach((freq, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sine';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.1, now + i * 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.05 + 0.3);
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start(now + i * 0.05);
            osc.stop(now + i * 0.05 + 0.35);
        });
    }
}

class Trail {
    constructor(scene) {
        this.scene = scene;
        this.maxPoints = 30; // å¢åŠ è»Œè·¡é»æ•¸è®“ç·šæ¢æ›´æµæš¢
        this.points = [];
        
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(this.maxPoints * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.LineBasicMaterial({ 
            color: 0xffffff, 
            linewidth: 3,
            transparent: true,
            opacity: 0.8
        });

        this.mesh = new THREE.Line(geometry, material);
        this.mesh.frustumCulled = false;
        this.scene.add(this.mesh);
    }

    update(mousePos, isDown) {
        if (isDown) {
            this.points.push(mousePos.clone());
            if (this.points.length > this.maxPoints) {
                this.points.shift();
            }
        } else {
            if (this.points.length > 0) this.points.shift();
            if (this.points.length > 0) this.points.shift();
            if (this.points.length > 0) this.points.shift(); // åŠ å¿«æ¶ˆå¤±é€Ÿåº¦
        }

        const positions = this.mesh.geometry.attributes.position.array;
        let index = 0;
        
        for (let i = 0; i < this.points.length; i++) {
            positions[index++] = this.points[i].x;
            positions[index++] = this.points[i].y;
            positions[index++] = this.points[i].z;
        }
        
        const lastPoint = this.points.length > 0 ? this.points[this.points.length-1] : new THREE.Vector3(0,0,0);
        while(index < positions.length) {
            positions[index++] = lastPoint.x;
            positions[index++] = lastPoint.y;
            positions[index++] = lastPoint.z;
        }
        
        this.mesh.geometry.attributes.position.needsUpdate = true;
    }
}

class ParticleSystem {
    constructor(scene) {
        this.scene = scene;
        this.particles = [];
        this.geo = new THREE.BoxGeometry(0.15, 0.15, 0.15); // ç¨å¾®åŠ å¤§ç²’å­
    }

    emit(position, color, count = 10, speed = 1) {
        const mat = new THREE.MeshPhongMaterial({ color: color, shininess: 100 });
        
        for(let i=0; i<count; i++) {
            const mesh = new THREE.Mesh(this.geo, mat);
            mesh.position.copy(position);
            mesh.userData = {
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * speed,
                    (Math.random() - 0.5) * speed,
                    (Math.random() - 0.5) * speed
                ),
                life: 1.0 + Math.random() * 0.5,
                rotSpeed: new THREE.Vector3(Math.random(), Math.random(), Math.random())
            };
            this.scene.add(mesh);
            this.particles.push(mesh);
        }
    }

    update(dt) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.position.add(p.userData.velocity);
            p.rotation.x += p.userData.rotSpeed.x * 0.1;
            p.rotation.y += p.userData.rotSpeed.y * 0.1;
            p.userData.velocity.y -= 9.8 * dt * 0.5; 
            p.userData.life -= dt;
            p.scale.setScalar(p.userData.life);

            if (p.userData.life <= 0) {
                this.scene.remove(p);
                this.particles.splice(i, 1);
            }
        }
    }
}

class GameObject {
    constructor(type, scene) {
        this.type = type; 
        this.scene = scene;
        this.active = true;
        this.sliced = false;
        this.group = new THREE.Group();
        
        this.velocity = new THREE.Vector3(0, 0, 0);
        this.rotationAxis = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize();
        this.rotationSpeed = Math.random() * 2 + 1;

        this.createModel();
        this.scene.add(this.group);
    }

    createModel() {
        this.wholeMesh = new THREE.Group();
        this.slicedMesh1 = new THREE.Group(); 
        this.slicedMesh2 = new THREE.Group(); 

        let mainColor, interiorColor, geometry;

        switch(this.type) {
            case 'watermelon':
                mainColor = 0x2e8b57; 
                interiorColor = 0xff6347; 
                geometry = new THREE.SphereGeometry(1, 16, 16);
                break;
            case 'apple':
                mainColor = 0xff0000;
                interiorColor = 0xffffe0;
                geometry = new THREE.SphereGeometry(0.7, 16, 16);
                break;
            case 'banana':
                mainColor = 0xffd700;
                interiorColor = 0xffffe0;
                geometry = new THREE.CapsuleGeometry(0.4, 1.2, 4, 8);
                break;
            case 'pineapple':
                mainColor = 0xffa500;
                interiorColor = 0xffff00;
                geometry = new THREE.CylinderGeometry(0.6, 0.6, 1.5, 8);
                break;
            case 'bomb':
                mainColor = 0x111111;
                geometry = new THREE.SphereGeometry(1, 16, 16);
                break;
            default: 
                mainColor = 0x8b4513;
                interiorColor = 0x90ee90;
                geometry = new THREE.SphereGeometry(0.6, 16, 16);
        }

        if (this.type === 'bomb') {
            const mat = new THREE.MeshPhongMaterial({ color: mainColor, shininess: 100 });
            const mesh = new THREE.Mesh(geometry, mat);
            this.wholeMesh.add(mesh);
            
            const wickGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5);
            const wickMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const wick = new THREE.Mesh(wickGeo, wickMat);
            wick.position.y = 1;
            this.wholeMesh.add(wick);

            this.glowMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const light = new THREE.PointLight(0xff0000, 1, 3);
            this.wholeMesh.add(light);
            
            this.isBomb = true;
        } else {
            const mat = new THREE.MeshPhongMaterial({ color: mainColor });
            const whole = new THREE.Mesh(geometry, mat);
            this.wholeMesh.add(whole);
            this.isBomb = false;
            
            const innerMat = new THREE.MeshPhongMaterial({ color: interiorColor });
            
            // Half 1
            const h1 = new THREE.Mesh(geometry.clone(), mat);
            const c1 = new THREE.Mesh(new THREE.CircleGeometry(geometry.parameters.radius || 0.5, 16), innerMat);
            h1.scale.set(1, 1, 0.5); 
            h1.position.z = 0.25;
            c1.position.z = 0;
            c1.rotation.y = Math.PI;
            this.slicedMesh1.add(h1);
            this.slicedMesh1.add(c1);
            
            // Half 2
            const h2 = new THREE.Mesh(geometry.clone(), mat);
            const c2 = new THREE.Mesh(new THREE.CircleGeometry(geometry.parameters.radius || 0.5, 16), innerMat);
            h2.scale.set(1, 1, 0.5);
            h2.position.z = -0.25;
            this.slicedMesh2.add(h2);
            this.slicedMesh2.add(c2);
            
            this.slicedMesh1.visible = false;
            this.slicedMesh2.visible = false;
            this.group.add(this.slicedMesh1);
            this.group.add(this.slicedMesh2);
            
            this.juiceColor = interiorColor;
        }

        this.group.add(this.wholeMesh);
    }

    update(dt) {
        if (!this.active) return;

        this.velocity.y -= 15 * dt; 
        this.group.position.add(this.velocity.clone().multiplyScalar(dt));

        if (!this.sliced) {
            this.group.rotation.x += this.rotationAxis.x * this.rotationSpeed * dt;
            this.group.rotation.y += this.rotationAxis.y * this.rotationSpeed * dt;
            
            if (this.isBomb) {
                const s = 1 + Math.sin(Date.now() * 0.01) * 0.2;
                this.wholeMesh.scale.setScalar(s);
            }
        } else {
            this.slicedMesh1.position.add(this.slicedVel1.clone().multiplyScalar(dt));
            this.slicedMesh1.rotation.z += 2 * dt;
            
            this.slicedMesh2.position.add(this.slicedVel2.clone().multiplyScalar(dt));
            this.slicedMesh2.rotation.z -= 2 * dt;
        }

        if (this.group.position.y < -15) {
            this.active = false;
            this.scene.remove(this.group);
            return "missed";
        }
        return "active";
    }

    slice(directionVec) {
        if (this.sliced || this.isBomb) return;
        
        this.sliced = true;
        this.wholeMesh.visible = false;
        this.slicedMesh1.visible = true;
        this.slicedMesh2.visible = true;

        const normal = new THREE.Vector3(directionVec.y, -directionVec.x, 0).normalize();
        
        this.slicedVel1 = new THREE.Vector3(normal.x, normal.y, 1).multiplyScalar(3);
        this.slicedVel2 = new THREE.Vector3(-normal.x, -normal.y, -1).multiplyScalar(3);
    }
}

class GameApp {
    constructor() {
        this.initThree();
        
        // ä½¿ç”¨ Clock ä¾†è¨ˆç®—ç²¾ç¢ºçš„ deltaTime
        this.clock = new THREE.Clock();
        
        this.audio = new SoundManager();
        this.particles = new ParticleSystem(this.scene);
        this.trail = new Trail(this.scene);

        this.objects = [];
        this.score = 0;
        this.lives = 3;
        this.bestScore = localStorage.getItem('fruitSliceBest') || 0;
        this.mode = 'menu'; 
        this.gameTime = 0;
        this.spawnTimer = 0;
        this.spawnRate = 1.5; 

        this.mouse = new THREE.Vector2();
        this.prevMouse = new THREE.Vector2();
        this.isMouseDown = false;
        this.raycaster = new THREE.Raycaster();
        this.mouseWorldPos = new THREE.Vector3();
        this.hasMoved = false; // è¿½è¹¤æ˜¯å¦æœ‰ç§»å‹•éï¼Œé¿å…åˆå§‹èª¤åˆ¤

        this.comboCount = 0;
        this.comboTimer = 0;

        this.ui = {
            score: document.getElementById('score-val'),
            best: document.getElementById('best-val'),
            lives: document.getElementById('lives-icons'),
            timer: document.getElementById('timer-display'),
            combo: document.getElementById('combo-display'),
            startScreen: document.getElementById('start-screen'),
            gameOverScreen: document.getElementById('game-over-screen'),
            finalScore: document.getElementById('final-score')
        };
        
        this.setupInput();
        this.updateUI();
        this.animate();
    }

    initThree() {
        this.container = document.getElementById('canvas-container');
        this.scene = new THREE.Scene();
        
        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        this.camera.position.set(0, 0, 18);
        this.camera.lookAt(0, 0, 0);

        this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.container.appendChild(this.renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        this.scene.add(dirLight);
    }

    setupInput() {
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });

        const updateMousePos = (x, y) => {
            this.mouse.x = (x / window.innerWidth) * 2 - 1;
            this.mouse.y = -(y / window.innerHeight) * 2 + 1;

            this.mouseWorldPos.set(this.mouse.x, this.mouse.y, 0.5);
            this.mouseWorldPos.unproject(this.camera);
            const dir = this.mouseWorldPos.sub(this.camera.position).normalize();
            const distance = -this.camera.position.z / dir.z;
            this.mouseWorldPos = this.camera.position.clone().add(dir.multiplyScalar(distance));
        };

        const handleStart = (x, y) => {
            this.isMouseDown = true;
            this.hasMoved = false;
            this.audio.ctx.resume();
            updateMousePos(x, y);
            this.prevMouse.copy(this.mouseWorldPos); // é‡ç½®ä¸Šä¸€ä½ç½®ï¼Œé˜²æ­¢ç¬ç§»åˆ‡å‰²
        };

        const handleMove = (x, y) => {
            if (this.isMouseDown) {
                this.hasMoved = true;
            }
            updateMousePos(x, y);
        };

        const handleEnd = () => {
            this.isMouseDown = false;
            this.hasMoved = false;
        };

        // Mouse Events
        document.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        document.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        document.addEventListener('mouseup', handleEnd);

        // Touch Events (ä½¿ç”¨ passive: false é˜²æ­¢æ²å‹•)
        this.container.addEventListener('touchstart', e => {
            e.preventDefault(); // é—œéµï¼šé˜²æ­¢è§¸æ§è§¸ç™¼æ»‘é¼ æ¨¡æ“¬äº‹ä»¶èˆ‡æ²å‹•
            handleStart(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        
        this.container.addEventListener('touchmove', e => {
            e.preventDefault();
            handleMove(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        
        this.container.addEventListener('touchend', e => {
            e.preventDefault();
            handleEnd();
        });
    }

    startGame(mode) {
        this.mode = 'playing';
        this.gameModeType = mode;
        this.score = 0;
        this.lives = 3;
        this.gameTime = 0;
        this.spawnTimer = 0;
        this.comboCount = 0;
        
        this.objects.forEach(obj => this.scene.remove(obj.group));
        this.objects = [];

        this.ui.startScreen.classList.add('hidden');
        this.ui.gameOverScreen.classList.add('hidden');
        
        if (mode === 'time') {
            this.timeLeft = 60;
            this.ui.timer.style.display = 'block';
            this.ui.lives.style.display = 'none';
        } else if (mode === 'arcade') {
            this.timeLeft = 60;
            this.ui.timer.style.display = 'block';
            this.ui.lives.style.display = 'none';
            this.lives = 999;
        } else {
            this.ui.timer.style.display = 'none';
            this.ui.lives.style.display = 'block';
        }

        this.updateUI();
        this.audio.playThrow();
    }

    showMenu() {
        this.mode = 'menu';
        this.ui.startScreen.classList.remove('hidden');
        this.ui.gameOverScreen.classList.add('hidden');
    }

    restartGame() {
        this.startGame(this.gameModeType);
    }

    spawnObject() {
        const types = ['watermelon', 'apple', 'banana', 'pineapple', 'kiwi'];
        
        let type = types[Math.floor(Math.random() * types.length)];
        const bombChance = this.gameModeType === 'arcade' ? 0.3 : 0.15;
        
        if (Math.random() < bombChance && this.gameTime > 2.0) { 
            type = 'bomb';
        }

        const obj = new GameObject(type, this.scene);
        
        const xPos = (Math.random() - 0.5) * 10; 
        obj.group.position.set(xPos, -12, 0); 
        
        const xVel = -xPos * (0.2 + Math.random() * 0.3); 
        const yVel = 14 + Math.random() * 6; 
        
        obj.velocity.set(xVel, yVel, 0);
        
        this.objects.push(obj);
        this.audio.playThrow();
    }

    handleSlicing(dt) {
        if (!this.isMouseDown || !this.hasMoved) {
            this.prevMouse.copy(this.mouseWorldPos);
            return;
        }

        const dist = this.mouseWorldPos.distanceTo(this.prevMouse);
        
        // ä½¿ç”¨å¯¦éš›çš„ dt ä¾†è¨ˆç®—é€Ÿåº¦ï¼Œé¿å…é«˜åˆ·æ–°ç‡è¢å¹•åˆ¤å®šå¤±æ•ˆ
        // é€Ÿåº¦ = è·é›¢ / æ™‚é–“
        // é˜²æ­¢ dt éå°å°è‡´é™¤ä»¥é›¶
        const safeDt = Math.max(dt, 0.001);
        const speed = dist / safeDt;

        // é™ä½é€Ÿåº¦é–€æª» (10 -> 4)ï¼Œè®“ä¼‘é–’æ»‘å‹•æ›´å®¹æ˜“è§¸ç™¼
        if (speed > 4) {
            const line3 = new THREE.Line3(this.prevMouse, this.mouseWorldPos);
            const closestPoint = new THREE.Vector3();

            this.objects.forEach(obj => {
                if (obj.active && !obj.sliced) {
                    line3.closestPointToPoint(obj.group.position, true, closestPoint);
                    const distanceToRay = closestPoint.distanceTo(obj.group.position);
                    
                    // ç¨å¾®åŠ å¤§ç¢°æ’åŠå¾‘ (1.2 -> 1.5) è®“åˆ¤å®šæ›´å¯¬å®¹
                    if (distanceToRay < 1.5) {
                        this.sliceObject(obj, this.mouseWorldPos.clone().sub(this.prevMouse).normalize());
                    }
                }
            });
        }

        this.prevMouse.copy(this.mouseWorldPos);
    }

    sliceObject(obj, direction) {
        if (obj.isBomb) {
            this.audio.playExplosion();
            this.particles.emit(obj.group.position, 0xff0000, 30, 5);
            this.handleBombHit();
            obj.active = false;
            this.scene.remove(obj.group);
        } else {
            obj.slice(direction);
            this.audio.playSquish();
            this.particles.emit(obj.group.position, obj.juiceColor, 15, 3);
            
            this.score++;
            
            this.comboCount++;
            this.comboTimer = 0.5; 
            
            if (this.comboCount > 1) {
                this.score += this.comboCount; 
                this.audio.playCombo();
                this.showComboUI(this.comboCount);
            } else {
                this.audio.playSlice();
            }

            this.updateUI();
        }
    }

    handleBombHit() {
        this.renderer.domElement.style.filter = 'brightness(3) sepia(1) hue-rotate(-50deg)';
        setTimeout(() => {
            this.renderer.domElement.style.filter = 'none';
        }, 100);

        if (this.gameModeType === 'classic') {
            this.lives--;
            this.updateUI();
            if (this.lives <= 0) this.gameOver();
        } else if (this.gameModeType === 'time') {
            this.score = Math.max(0, this.score - 5);
            this.updateUI();
        } else {
            this.score = Math.max(0, this.score - 10);
            this.updateUI();
        }
    }

    showComboUI(count) {
        this.ui.combo.innerText = `COMBO x${count}`;
        this.ui.combo.style.opacity = 1;
        this.ui.combo.style.transform = 'rotate(-15deg) scale(1.5)';
        
        clearTimeout(this.comboAnimTimer);
        this.comboAnimTimer = setTimeout(() => {
            this.ui.combo.style.opacity = 0;
            this.ui.combo.style.transform = 'rotate(-15deg) scale(1)';
        }, 500);
    }

    gameOver() {
        this.mode = 'gameover';
        if (this.score > this.bestScore) {
            this.bestScore = this.score;
            localStorage.setItem('fruitSliceBest', this.bestScore);
        }
        this.ui.finalScore.innerText = this.score;
        this.ui.gameOverScreen.classList.remove('hidden');
        this.updateUI();
        this.audio.playExplosion();
    }

    updateUI() {
        this.ui.score.innerText = this.score;
        this.ui.best.innerText = this.bestScore;
        
        let livesStr = '';
        for(let i=0; i<this.lives; i++) livesStr += 'X ';
        this.ui.lives.innerText = livesStr;
    }

    animate() {
        requestAnimationFrame(this.animate.bind(this));
        
        // ç²å–çœŸå¯¦çš„æ™‚é–“å·®
        const dt = this.clock.getDelta();
        // é™åˆ¶ dt æœ€å¤§å€¼ï¼Œé˜²æ­¢åˆ‡æ›åˆ†é å›ä¾†æ™‚ç‰©é«”ç¬é–“é£›èµ°
        const cappedDt = Math.min(dt, 0.1);
        
        this.trail.update(this.mouseWorldPos, this.isMouseDown && this.mode === 'playing');

        if (this.mode === 'playing') {
            this.gameTime += cappedDt;
            this.spawnTimer -= cappedDt;
            
            if (this.comboTimer > 0) {
                this.comboTimer -= cappedDt;
                if (this.comboTimer <= 0) this.comboCount = 0;
            }

            if (this.spawnTimer <= 0) {
                let spawnCount = 1;
                if (this.gameTime > 10) spawnCount = Math.random() > 0.5 ? 2 : 1;
                if (this.gameTime > 30) spawnCount = Math.floor(Math.random() * 3) + 1;
                if (this.gameModeType === 'arcade') spawnCount += 2;

                for(let i=0; i<spawnCount; i++) {
                    this.spawnObject();
                }
                
                const difficultyMod = Math.max(0.5, 1.5 - (this.gameTime * 0.01));
                this.spawnRate = (this.gameModeType === 'arcade' ? 0.5 : 1.0) * difficultyMod;
                this.spawnTimer = this.spawnRate + Math.random() * 0.5;
            }

            if (this.gameModeType === 'time' || this.gameModeType === 'arcade') {
                this.timeLeft -= cappedDt;
                this.ui.timer.innerText = Math.ceil(this.timeLeft);
                if (this.timeLeft <= 0) {
                    this.gameOver();
                }
            }

            this.handleSlicing(cappedDt);
            
            for (let i = this.objects.length - 1; i >= 0; i--) {
                const status = this.objects[i].update(cappedDt);
                if (status === 'missed') {
                    if (!this.objects[i].isBomb && !this.objects[i].sliced && this.gameModeType === 'classic') {
                        this.lives--;
                        this.updateUI();
                        if (this.lives <= 0) {
                            this.gameOver();
                            break;
                        }
                    }
                    this.objects.splice(i, 1);
                } else if (!this.objects[i].active) {
                    this.objects.splice(i, 1); 
                }
            }
        }

        this.particles.update(cappedDt);
        this.renderer.render(this.scene, this.camera);
    }
}

window.gameApp = new GameApp();

</script>
</body>
</html>
