<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Math Hunter 3D - Sky & Ground Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bangers&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* å¤©ç©ºè— */
            font-family: 'Bangers', 'Noto Sans TC', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; 
            overscroll-behavior: none;
            cursor: crosshair; /* æº–å¿ƒé¼ æ¨™ */
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            text-shadow: 2px 2px 0 #000;
        }

        /* æº–å¿ƒ */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            transition: transform 0.1s;
        }
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background: #ff3333;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            box-shadow: 0 0 4px #ff0000;
        }

        /* HUD */
        .hud-text {
            position: absolute;
            color: white;
            font-size: 1.5rem;
        }

        #score-display { top: 20px; left: 20px; color: #ffd700; font-size: 2rem; }
        #level-display { top: 60px; left: 20px; color: #00ffcc; }
        #best-score-display { top: 90px; left: 20px; font-size: 1rem; color: #ddd; }
        
        #lives-display { 
            top: 20px; 
            right: 20px; 
            text-align: right; 
            font-size: 2rem;
        }
        
        #message-display {
            position: absolute;
            top: 30%;
            width: 100%;
            text-align: center;
            font-size: 4rem;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        /* Menu Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 20;
        }

        .hidden { display: none !important; }

        h1 {
            font-size: 4rem;
            color: #ff9966;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 3px 3px 0 #5c3a21;
        }

        .menu-btn {
            font-family: 'Noto Sans TC', sans-serif;
            font-size: 1.5rem;
            padding: 15px 40px;
            margin: 10px;
            width: 280px;
            background: #5c3a21; /* æœ¨é ­è‰² */
            border: 3px solid #8b5a2b;
            color: #f0e68c;
            cursor: pointer;
            border-radius: 10px;
            transition: transform 0.1s;
            box-shadow: 0 5px 10px rgba(0,0,0,0.5);
        }

        .menu-btn:hover { transform: scale(1.05); background: #6d4c33; }
        .menu-btn:active { transform: scale(0.95); }

        .instruction-box {
            background: rgba(92, 58, 33, 0.9);
            padding: 20px 30px;
            border-radius: 15px;
            border: 2px solid #8b5a2b;
            margin-top: 20px;
            max-width: 600px;
            color: #f0e68c;
            font-family: 'Noto Sans TC', sans-serif;
            font-size: 1.1rem;
            line-height: 1.6;
        }
        
        .highlight { color: #00ff00; font-weight: bold; }
        .safe { color: #87CEEB; font-weight: bold; }
        .bad { color: #ff4444; font-weight: bold; }

    </style>
    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="crosshair"></div>

    <div id="ui-layer">
        <div id="score-display">åˆ†æ•¸: <span id="score-val">0</span></div>
        <div id="level-display">é—œå¡: <span id="level-val">1</span></div>
        <div id="best-score-display">æœ€é«˜åˆ†: <span id="best-val">0</span></div>
        <div id="lives-display">â¤ï¸ <span id="lives-val">3</span></div>
        <div id="message-display">HEADSHOT!</div>
    </div>

    <!-- Main Menu -->
    <div id="start-screen" class="screen">
        <h1>æ£®æ—æ•¸å­¸çµäºº<br><span style="font-size: 1.5rem; color: #87CEEB;">Sky & Ground</span></h1>
        
        <button class="menu-btn" onclick="gameApp.startGame()">é–‹å§‹ç‹©çµ</button>
        
        <div class="instruction-box">
            <h3>ğŸ¹ çµäººæŒ‡å— (é™¸ç©ºè¯åˆä½œæˆ°)</h3>
            <ul>
                <li><strong>ä»»å‹™ï¼š</strong>ä½¿ç”¨åå­—å¼“ï¼Œé˜²å®ˆä¾†è‡ªæ£®æ—èˆ‡å¤©ç©ºçš„æ•¸å­—å‹•ç‰©ã€‚</li>
                <li><strong>è¦å‰‡ï¼š</strong>
                    <ul>
                        <li><span class="highlight">è³ªæ•¸ (2, 3, 5, 7...)</span>ï¼šå¿…é ˆç‹©çµï¼(å°„æ“Šå¾—åˆ†)</li>
                        <li><span class="safe">éè³ªæ•¸ (4, 6, 8, 9...)</span>ï¼šè®“ç‰ é€šéï¼(ä¸è¦å°„æ“Šï¼Œå®‰å…¨)</li>
                    </ul>
                </li>
                <li><strong>æ³¨æ„å¤©ç©ºï¼š</strong>é³¥é¡ä¹Ÿæœƒæ”œå¸¶æ•¸å­—ï¼Œè«‹æŠ¬é ­è§€å¯Ÿï¼</li>
                <li><strong>å¤±æ•—æ¢ä»¶ï¼š</strong>
                    <ul>
                        <li><span class="bad">æ¼æ‰è³ªæ•¸</span>ï¼šè®“è³ªæ•¸å‹•ç‰©è·‘åˆ°é¢å‰æˆ–é£›éé ­é ‚ (æ‰£è¡€)</li>
                        <li><span class="bad">æ¿«æ®ºç„¡è¾œ</span>ï¼šå°„ä¸­éè³ªæ•¸ (æ‰£åˆ†)</li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="color: #ff4444;">é˜²ç·šå¤±å®ˆ</h1>
        <h2 style="color:white; font-size: 2.5rem;">æœ€çµ‚åˆ†æ•¸: <span id="final-score">0</span></h2>
        <button class="menu-btn" onclick="gameApp.restartGame()">å†æ¬¡æŒ‘æˆ°</button>
        <button class="menu-btn" onclick="gameApp.showMenu()">å›ä¸»é¸å–®</button>
    </div>

<script type="module">
import * as THREE from 'three';

// è³ªæ•¸è¡¨å¿«å–
function isPrime(num) {
    if (num <= 1) return false;
    if (num <= 3) return true;
    if (num % 2 === 0 || num % 3 === 0) return false;
    for (let i = 5; i * i <= num; i += 6) {
        if (num % i === 0 || num % (i + 2) === 0) return false;
    }
    return true;
}

// éŸ³æ•ˆç®¡ç†
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.4;
        this.masterGain.connect(this.ctx.destination);
    }

    playShoot() {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(800, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.15);
    }

    playHit() { // ç©å®¶å—å‚·
        if (this.ctx.state === 'suspended') return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.2);
    }

    playCorrect() { // å°„ä¸­è³ªæ•¸
        if (this.ctx.state === 'suspended') return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(523.25, this.ctx.currentTime); 
        osc.frequency.setValueAtTime(783.99, this.ctx.currentTime + 0.1); 
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
    }
    
    playWrong() { // å°„éŒ¯
        if (this.ctx.state === 'suspended') return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 0.2);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
    }
}

// ç©å®¶çš„åå­—å¼“
class Crossbow {
    constructor(scene, camera) {
        this.scene = scene;
        this.camera = camera;
        this.group = new THREE.Group();
        
        const woodMat = new THREE.MeshPhongMaterial({ color: 0x5D4037 });
        const metalMat = new THREE.MeshPhongMaterial({ color: 0x607D8B, shininess: 100 });
        const stringMat = new THREE.LineBasicMaterial({ color: 0xEEEEEE });

        // æ§æ‰˜
        const stockGeo = new THREE.BoxGeometry(0.15, 0.1, 0.8);
        const stock = new THREE.Mesh(stockGeo, woodMat);
        stock.position.z = 0.2;
        this.group.add(stock);
        
        // å¼“è‡‚
        const limbGeo = new THREE.BoxGeometry(0.08, 0.05, 0.6);
        const leftLimb = new THREE.Mesh(limbGeo, woodMat);
        leftLimb.position.set(-0.25, 0, -0.2);
        leftLimb.rotation.y = -Math.PI / 4;
        this.group.add(leftLimb);

        const rightLimb = new THREE.Mesh(limbGeo, woodMat);
        rightLimb.position.set(0.25, 0, -0.2);
        rightLimb.rotation.y = Math.PI / 4;
        this.group.add(rightLimb);

        // å¼¦
        const points = [
            new THREE.Vector3(-0.45, 0, -0.4),
            new THREE.Vector3(0, 0, 0.4),     
            new THREE.Vector3(0.45, 0, -0.4) 
        ];
        const stringGeo = new THREE.BufferGeometry().setFromPoints(points);
        this.stringLine = new THREE.Line(stringGeo, stringMat);
        this.group.add(this.stringLine);

        // è»Œé“
        const railGeo = new THREE.BoxGeometry(0.05, 0.02, 0.8);
        const rail = new THREE.Mesh(railGeo, metalMat);
        rail.position.y = 0.06;
        stock.add(rail);

        this.scene.add(this.group);
        
        this.isFiring = false;
        this.fireTime = 0;
    }

    update(mouse, time) {
        // å‘¼å¸æ•ˆæœ
        const breathe = Math.sin(time * 1.5) * 0.003;
        
        // è·Ÿéš¨æ»‘é¼ 
        const targetX = mouse.x * 0.8; // å¢åŠ æ°´å¹³ç§»å‹•ç¯„åœ
        const targetY = mouse.y * 0.8; // å¢åŠ å‚ç›´ç§»å‹•ç¯„åœ
        
        // è½‰æ›åˆ°ç›¸æ©Ÿç©ºé–“
        const vector = new THREE.Vector3(0.3 + targetX * 0.15, -0.3 + targetY * 0.15 + breathe, -0.5);
        vector.applyQuaternion(this.camera.quaternion);
        vector.add(this.camera.position);
        
        this.group.position.copy(vector);
        this.group.quaternion.copy(this.camera.quaternion);
        this.group.rotateX(0.08); // ç¨å¾®æŠ¬é«˜æ§å£
        this.group.rotateY(-0.05); 

        if (this.isFiring) {
            const progress = (time - this.fireTime) * 15;
            if (progress < 1) {
                this.group.translateZ(progress * 0.15); // å¾Œåº§åŠ›
            } else if (progress < 3) {
                this.group.translateZ(0.15 - (progress-1) * 0.075);
            } else {
                this.isFiring = false;
            }
        }
    }
    
    trigger() {
        this.isFiring = true;
        this.fireTime = performance.now() / 1000;
    }
}

// å¼©ç®­
class Bolt {
    constructor(scene, position, direction) {
        this.scene = scene;
        this.active = true;
        this.speed = 100;
        this.direction = direction.normalize();
        
        this.group = new THREE.Group();
        this.group.position.copy(position);
        
        const shaftGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.4, 8);
        const shaftMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const shaft = new THREE.Mesh(shaftGeo, shaftMat);
        shaft.rotation.x = Math.PI / 2;
        this.group.add(shaft);
        
        const tipGeo = new THREE.ConeGeometry(0.03, 0.1, 8);
        const tipMat = new THREE.MeshPhongMaterial({ color: 0xC0C0C0 });
        const tip = new THREE.Mesh(tipGeo, tipMat);
        tip.rotation.x = Math.PI / 2;
        tip.position.z = 0.25;
        this.group.add(tip);
        
        const fletchGeo = new THREE.BoxGeometry(0.005, 0.08, 0.1);
        const fletchMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const fletch = new THREE.Mesh(fletchGeo, fletchMat);
        fletch.position.z = -0.15;
        this.group.add(fletch);
        
        this.group.lookAt(this.group.position.clone().add(this.direction));
        this.scene.add(this.group);
    }

    update(dt) {
        if (!this.active) return;
        this.group.position.add(this.direction.clone().multiplyScalar(this.speed * dt));
        if (this.group.position.length() > 150) {
            this.destroy();
        }
    }

    destroy() {
        this.active = false;
        this.scene.remove(this.group);
    }
}

// å‹•ç‰©å·¥å»  (æ•´åˆåœ°é¢èˆ‡é£›è¡Œ)
class Animal {
    constructor(scene, level) {
        this.scene = scene;
        this.active = true;
        this.group = new THREE.Group();
        this.wings = []; // å„²å­˜ç¿…è†€ä»¥ä¾¿å‹•ç•«ä½¿ç”¨
        
        this.number = Math.floor(Math.random() * 98) + 2;
        this.isPrime = isPrime(this.number);
        
        // æ±ºå®šæ˜¯åœ°é¢é‚„æ˜¯å¤©ç©º (35% æ©Ÿç‡æ˜¯å¤©ç©º)
        this.domain = Math.random() > 0.65 ? 'sky' : 'ground';

        if (this.domain === 'ground') {
            const types = ['boar', 'rabbit', 'fox'];
            this.type = types[Math.floor(Math.random() * types.length)];
            this.buildGroundModel();
            
            // ç”Ÿæˆä½ç½® (åœ°é¢)
            const startZ = -40 - Math.random() * 20;
            const startX = (Math.random() - 0.5) * 30;
            this.group.position.set(startX, 0, startZ);
            
            // åœ°é¢åŸºç¤é€Ÿåº¦
            const baseSpeed = this.type === 'rabbit' ? 8 : (this.type === 'fox' ? 7 : 5);
            this.speed = baseSpeed + (level * 0.5);

        } else {
            const types = ['eagle', 'owl'];
            this.type = types[Math.floor(Math.random() * types.length)];
            this.buildSkyModel();

            // ç”Ÿæˆä½ç½® (å¤©ç©º)
            const startZ = -50 - Math.random() * 20; // é£›å¾—æ¯”è¼ƒé é–‹å§‹
            const startX = (Math.random() - 0.5) * 40; // ç¯„åœæ›´å»£
            const startY = 6 + Math.random() * 8; // é«˜åº¦ 6~14
            this.group.position.set(startX, startY, startZ);

            // å¤©ç©ºåŸºç¤é€Ÿåº¦ (é€šå¸¸æ¯”åœ°é¢å¿«)
            this.speed = 10 + (level * 0.8);
        }
        
        // æ•¸å­—é¡¯ç¤º (Billboard)
        this.createNumberBillboard();
        
        this.group.lookAt(0, this.domain === 'sky' ? 5 : 0, 0); // åœ°é¢çœ‹åœ°æ¿ï¼Œå¤©ç©ºçœ‹ç©ºä¸­æŸé»
        
        this.animTime = Math.random();
        this.scene.add(this.group);
    }

    createNumberBillboard() {
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = this.isPrime ? '#32CD32' : '#FFFFFF'; 
        ctx.font = 'bold 160px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 12;
        ctx.lineJoin = 'round';
        ctx.strokeText(this.number, 128, 128);
        ctx.fillText(this.number, 128, 128);
        
        const tex = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ map: tex });
        const sprite = new THREE.Sprite(spriteMat);
        
        // èª¿æ•´æ•¸å­—ä½ç½®
        if (this.domain === 'sky') {
            sprite.position.y = -0.8; // é£›è¡Œç”Ÿç‰©ï¼Œæ•¸å­—åœ¨ä¸‹æ–¹æ¯”è¼ƒå¥½ç„æº–
        } else {
            sprite.position.y = 2.0; // åœ°é¢ç”Ÿç‰©ï¼Œæ•¸å­—åœ¨ä¸Šæ–¹
        }
        
        sprite.scale.set(1.5, 1.5, 1);
        this.group.add(sprite);
    }

    buildGroundModel() {
        let mainColor;
        if (this.type === 'boar') {
            mainColor = 0x5D4037;
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1, 1.8), new THREE.MeshPhongMaterial({color: mainColor}));
            body.position.y = 0.8;
            this.group.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 1), new THREE.MeshPhongMaterial({color: mainColor}));
            head.position.set(0, 1.0, 1.2);
            this.group.add(head);
        } else if (this.type === 'rabbit') {
            mainColor = 0xDCDCDC;
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), new THREE.MeshPhongMaterial({color: mainColor}));
            body.scale.set(1, 0.8, 1.2);
            body.position.y = 0.5;
            this.group.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 16), new THREE.MeshPhongMaterial({color: mainColor}));
            head.position.set(0, 0.8, 0.6);
            this.group.add(head);
            const ear1 = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 0.5, 4, 8), new THREE.MeshPhongMaterial({color: mainColor}));
            ear1.position.set(0.15, 1.2, 0.5);
            ear1.rotation.x = -0.2;
            this.group.add(ear1);
            const ear2 = ear1.clone();
            ear2.position.set(-0.15, 1.2, 0.5);
            this.group.add(ear2);
        } else { // Fox
            mainColor = 0xFF8C00;
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.6, 1.2), new THREE.MeshPhongMaterial({color: mainColor}));
            body.position.y = 0.6;
            this.group.add(body);
            const head = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 16), new THREE.MeshPhongMaterial({color: mainColor}));
            head.rotation.x = -Math.PI/2;
            head.position.set(0, 1.0, 0.8);
            this.group.add(head);
            const tail = new THREE.Mesh(new THREE.CapsuleGeometry(0.2, 0.8, 4, 8), new THREE.MeshPhongMaterial({color: mainColor}));
            tail.rotation.x = Math.PI/3;
            tail.position.set(0, 0.8, -0.8);
            this.group.add(tail);
        }
    }

    buildSkyModel() {
        let color;
        // èº«é«”
        if (this.type === 'eagle') {
            color = 0x8B4513; // SaddleBrown
        } else { // owl
            color = 0x708090; // SlateGray
        }
        
        const bodyGeo = new THREE.ConeGeometry(0.4, 1.2, 8);
        const body = new THREE.Mesh(bodyGeo, new THREE.MeshPhongMaterial({color: color}));
        body.rotation.x = Math.PI / 2;
        this.group.add(body);
        
        // é ­éƒ¨
        const headGeo = new THREE.SphereGeometry(0.35, 16, 16);
        const head = new THREE.Mesh(headGeo, new THREE.MeshPhongMaterial({color: this.type === 'eagle' ? 0xFFFFFF : color}));
        head.position.z = 0.6;
        head.position.y = 0.2;
        this.group.add(head);
        
        // å˜´å·´
        const beakGeo = new THREE.ConeGeometry(0.1, 0.3, 8);
        const beak = new THREE.Mesh(beakGeo, new THREE.MeshPhongMaterial({color: 0xFFD700}));
        beak.rotation.x = Math.PI / 2;
        beak.position.z = 0.9;
        beak.position.y = 0.15;
        this.group.add(beak);

        // ç¿…è†€ (ç”¨æ–¼å‹•ç•«)
        const wingGeo = new THREE.BoxGeometry(1.2, 0.1, 0.6);
        const wingMat = new THREE.MeshPhongMaterial({color: color});
        
        // å·¦ç¿…
        const leftWing = new THREE.Mesh(wingGeo, wingMat);
        leftWing.position.set(-0.6, 0.2, 0);
        // è¨­å®šæ—‹è½‰ä¸­å¿ƒåœ¨é è¿‘èº«é«”çš„ä¸€å´
        leftWing.geometry.translate(-0.6, 0, 0); 
        leftWing.position.set(0, 0.1, 0);
        this.group.add(leftWing);
        this.wings.push(leftWing);

        // å³ç¿…
        const rightWing = new THREE.Mesh(wingGeo, wingMat);
        // è¨­å®šæ—‹è½‰ä¸­å¿ƒ
        rightWing.geometry.translate(0.6, 0, 0);
        rightWing.position.set(0, 0.1, 0);
        this.group.add(rightWing);
        this.wings.push(rightWing);
    }

    update(dt) {
        if (!this.active) return;
        
        // å‹•ç•«æ™‚é–“
        this.animTime += dt * (this.domain === 'sky' ? 10 : 12);

        // ç§»å‹•é‚è¼¯
        if (this.domain === 'ground') {
            // åœ°é¢ï¼šè·‘å‘ (0,0,0)
            const dir = this.group.position.clone().negate().normalize(); 
            dir.y = 0;
            this.group.position.add(dir.multiplyScalar(this.speed * dt));
            this.group.lookAt(0, 0, 0); 
            
            // è·³å‹•
            const bounce = Math.abs(Math.sin(this.animTime)) * (this.type === 'rabbit' ? 0.4 : 0.15);
            this.group.position.y = bounce;

            // ç¢°æ’/åˆ°é”æª¢æ¸¬ (Zè»¸è·é›¢ç¸®çŸ­)
            if (this.group.position.length() < 3.0) return "reached_player";

        } else {
            // å¤©ç©ºï¼šé£›è¶Šç©å®¶é ­é ‚
            // ç›®æ¨™é»æ˜¯ç©å®¶èº«å¾Œçš„ä¸€é» (0, é«˜åº¦, 20)
            const target = new THREE.Vector3(0, this.group.position.y, 20); 
            const dir = target.sub(this.group.position).normalize();
            
            this.group.position.add(dir.multiplyScalar(this.speed * dt));
            this.group.lookAt(0, this.group.position.y, 50); // ç¨å¾®çœ‹å‘é æ–¹
            
            // æ‹å‹•ç¿…è†€
            const flap = Math.sin(this.animTime) * 0.5;
            // å·¦ç¿…è½‰å‹•
            this.wings[0].rotation.z = flap;
            // å³ç¿…è½‰å‹• (åå‘)
            this.wings[1].rotation.z = -flap;
            
            // ä¸Šä¸‹æµ®å‹•
            this.group.position.y += Math.sin(this.animTime * 0.5) * 0.02;

            // é£›è¡Œåˆ¤å®šï¼šå¦‚æœ Z > 5 (é£›éç›¸æ©Ÿä½ç½®)ï¼Œå°±ç®—åˆ°é”
            if (this.group.position.z > 5.0) return "reached_player";
        }

        return "moving";
    }

    destroy() {
        this.active = false;
        this.scene.remove(this.group);
        // æ¸…ç† geometry/material å»ºè­°åœ¨å¤§å‹å°ˆæ¡ˆåšï¼Œé€™è£¡ç°¡åŒ–
    }
}

class GameApp {
    constructor() {
        this.initThree();
        this.clock = new THREE.Clock();
        this.audio = new SoundManager();
        
        this.crossbow = new Crossbow(this.scene, this.camera);
        
        this.bolts = [];
        this.animals = [];
        
        this.score = 0;
        this.lives = 3;
        this.level = 1;
        this.bestScore = localStorage.getItem('mathHunterSkyBest') || 0;
        this.spawnTimer = 0;
        
        this.mouse = new THREE.Vector2();
        this.raycaster = new THREE.Raycaster();

        this.ui = {
            score: document.getElementById('score-val'),
            level: document.getElementById('level-val'),
            best: document.getElementById('best-val'),
            lives: document.getElementById('lives-val'),
            message: document.getElementById('message-display'),
            startScreen: document.getElementById('start-screen'),
            gameOverScreen: document.getElementById('game-over-screen'),
            finalScore: document.getElementById('final-score')
        };
        
        this.setupInput();
        this.updateUI();
        this.animate();
    }

    initThree() {
        this.container = document.getElementById('canvas-container');
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.Fog(0x87CEEB, 20, 80); // éœ§ç¨å¾®èª¿é ä¸€é»é©æ‡‰å¤©ç©º
        
        // åœ°æ¿
        const groundGeo = new THREE.PlaneGeometry(200, 200);
        const groundMat = new THREE.MeshPhongMaterial({ color: 0x4CAF50 }); 
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        this.scene.add(ground);
        
        // æ¨¹æœ¨ (è£é£¾)
        for(let i=0; i<30; i++) {
            const tree = new THREE.Group();
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.6, 3), 
                new THREE.MeshPhongMaterial({color: 0x795548})
            );
            trunk.position.y = 1.5;
            
            const leaves = new THREE.Mesh(
                new THREE.ConeGeometry(2.5, 5, 8),
                new THREE.MeshPhongMaterial({color: 0x2E7D32})
            );
            leaves.position.y = 4;
            
            tree.add(trunk);
            tree.add(leaves);
            
            const angle = Math.random() * Math.PI * 2;
            const dist = 25 + Math.random() * 40;
            tree.position.set(Math.cos(angle)*dist, 0, Math.sin(angle)*dist);
            this.scene.add(tree);
        }

        // Camera
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        this.camera.position.set(0, 1.6, 0); 
        this.camera.lookAt(0, 1.6, -10);

        // Renderer
        this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.container.appendChild(this.renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        this.scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 15, 10);
        this.scene.add(dirLight);
    }

    setupInput() {
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });

        const handleMove = (x, y) => {
            this.mouse.x = (x / window.innerWidth) * 2 - 1;
            this.mouse.y = -(y / window.innerHeight) * 2 + 1;
        };

        const handleShoot = () => {
            if (this.mode !== 'playing') return;
            
            this.audio.playShoot();
            this.crossbow.trigger();
            
            // è¨ˆç®—å°„æ“Šæ–¹å‘
            this.raycaster.setFromCamera(this.mouse, this.camera);
            const direction = this.raycaster.ray.direction.clone();
            
            // å¼©ç®­èµ·é»
            const startPos = this.camera.position.clone().add(direction.multiplyScalar(0.5));
            startPos.y -= 0.1;
            
            this.bolts.push(new Bolt(this.scene, startPos, this.raycaster.ray.direction));
        };

        document.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        document.addEventListener('mousedown', handleShoot);
        
        // Touch
        this.container.addEventListener('touchmove', e => {
            e.preventDefault();
            handleMove(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        this.container.addEventListener('touchstart', e => {
            e.preventDefault();
            handleMove(e.touches[0].clientX, e.touches[0].clientY);
            handleShoot();
        }, {passive: false});
    }

    startGame() {
        this.mode = 'playing';
        this.score = 0;
        this.lives = 3;
        this.level = 1;
        this.spawnTimer = 0;
        
        this.animals.forEach(a => a.destroy());
        this.bolts.forEach(b => b.destroy());
        this.animals = [];
        this.bolts = [];

        this.ui.startScreen.classList.add('hidden');
        this.ui.gameOverScreen.classList.add('hidden');
        this.updateUI();
    }
    
    showMenu() {
        this.mode = 'menu';
        this.ui.startScreen.classList.remove('hidden');
        this.ui.gameOverScreen.classList.add('hidden');
    }

    restartGame() {
        this.startGame();
    }

    showMessage(text, color) {
        const el = this.ui.message;
        el.innerText = text;
        el.style.color = color;
        el.style.opacity = 1;
        el.style.top = '30%';
        
        setTimeout(() => {
            el.style.top = '25%';
            el.style.opacity = 0;
        }, 800);
    }

    checkCollisions() {
        for (let i = this.bolts.length - 1; i >= 0; i--) {
            const bolt = this.bolts[i];
            let hit = false;
            
            for (let j = this.animals.length - 1; j >= 0; j--) {
                const animal = this.animals[j];
                // 3D è·é›¢æª¢æ¸¬ï¼Œå°å¤©ç©ºç›®æ¨™åŒæ¨£æœ‰æ•ˆ
                const dist = bolt.group.position.distanceTo(animal.group.position);
                
                // ç¢°æ’åˆ¤å®šç¯„åœ (çµ¦å¤©ç©ºå–®ä½å¤§ä¸€é»é»çš„åˆ¤å®šï¼Œæ¯”è¼ƒå¥½å°„)
                const hitRadius = animal.domain === 'sky' ? 2.5 : 1.8;
                
                if (dist < hitRadius) {
                    this.handleHit(animal);
                    animal.destroy();
                    this.animals.splice(j, 1);
                    hit = true;
                    break;
                }
            }
            
            if (hit) {
                bolt.destroy();
                this.bolts.splice(i, 1);
            }
        }
    }

    handleHit(animal) {
        if (animal.isPrime) {
            // æ­£ç¢ºå°„ä¸­è³ªæ•¸
            this.score += 10;
            this.audio.playCorrect();
            this.showMessage(`ç²¾æº–å‘½ä¸­! ${animal.number}`, '#00ff00');
            
            if (Math.floor(this.score / 100) + 1 > this.level) {
                this.level++;
                this.showMessage(`LEVEL UP! ${this.level}`, '#00ffff');
            }
        } else {
            // å°„ä¸­éè³ªæ•¸ (æ‰£åˆ†)
            this.score = Math.max(0, this.score - 5);
            this.audio.playWrong();
            this.showMessage(`ä¸å¯æ¿«æ®º! -5`, '#FFA500');
        }
        this.updateUI();
    }
    
    handleAnimalReachPlayer(animal) {
        if (animal.isPrime) {
            // è³ªæ•¸è·‘æ‰äº†/é£›éäº† -> æ‰£è¡€
            this.lives--;
            this.audio.playHit();
            this.renderer.domElement.style.filter = 'brightness(3) sepia(1) hue-rotate(-50deg)';
            setTimeout(() => { this.renderer.domElement.style.filter = 'none'; }, 100);
            
            const action = animal.domain === 'sky' ? 'é£›éé˜²ç·š' : 'è¡ç ´é˜²ç·š';
            this.showMessage(`æ¼æ‰çµç‰©! ${animal.number} ${action}`, '#ff0000');
            if (this.lives <= 0) this.gameOver();
        } else {
            // éè³ªæ•¸ -> å®‰å…¨é€šé
            this.showMessage(`å®‰å…¨é€šé`, '#87CEEB');
        }
        this.updateUI();
    }

    gameOver() {
        this.mode = 'gameover';
        if (this.score > this.bestScore) {
            this.bestScore = this.score;
            localStorage.setItem('mathHunterSkyBest', this.bestScore);
        }
        this.ui.finalScore.innerText = this.score;
        this.ui.gameOverScreen.classList.remove('hidden');
        this.updateUI();
    }

    updateUI() {
        this.ui.score.innerText = this.score;
        this.ui.level.innerText = this.level;
        this.ui.best.innerText = this.bestScore;
        this.ui.lives.innerText = this.lives;
    }

    animate() {
        requestAnimationFrame(this.animate.bind(this));
        
        const dt = Math.min(this.clock.getDelta(), 0.1);
        const time = this.clock.getElapsedTime();
        
        this.crossbow.update(this.mouse, time);

        if (this.mode === 'playing') {
            this.spawnTimer -= dt;

            if (this.spawnTimer <= 0) {
                this.animals.push(new Animal(this.scene, this.level));
                const spawnInterval = Math.max(0.6, 2.0 - (this.level * 0.12));
                this.spawnTimer = spawnInterval;
            }

            for (let i = this.bolts.length - 1; i >= 0; i--) {
                this.bolts[i].update(dt);
                if (!this.bolts[i].active) this.bolts.splice(i, 1);
            }

            for (let i = this.animals.length - 1; i >= 0; i--) {
                const status = this.animals[i].update(dt);
                if (status === "reached_player") {
                    this.handleAnimalReachPlayer(this.animals[i]);
                    this.animals[i].destroy();
                    this.animals.splice(i, 1);
                }
            }

            this.checkCollisions();
        }

        this.renderer.render(this.scene, this.camera);
    }
}

window.gameApp = new GameApp();

</script>
</body>
</html>
