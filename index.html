<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Math Hunter 3D - Crossbow Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bangers&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* å¤©ç©ºè— */
            font-family: 'Bangers', 'Noto Sans TC', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; 
            overscroll-behavior: none;
            cursor: crosshair; /* æº–å¿ƒé¼ æ¨™ */
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            text-shadow: 2px 2px 0 #000;
        }

        /* æº–å¿ƒ */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            transition: transform 0.1s;
        }
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background: #ff3333;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            box-shadow: 0 0 4px #ff0000;
        }

        /* HUD */
        .hud-text {
            position: absolute;
            color: white;
            font-size: 1.5rem;
        }

        #score-display { top: 20px; left: 20px; color: #ffd700; font-size: 2rem; }
        #level-display { top: 60px; left: 20px; color: #00ffcc; }
        #best-score-display { top: 90px; left: 20px; font-size: 1rem; color: #ddd; }
        
        #lives-display { 
            top: 20px; 
            right: 20px; 
            text-align: right; 
            font-size: 2rem;
        }
        
        #message-display {
            position: absolute;
            top: 30%;
            width: 100%;
            text-align: center;
            font-size: 4rem;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        /* Menu Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 20;
        }

        .hidden { display: none !important; }

        h1 {
            font-size: 4rem;
            color: #ff9966;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 3px 3px 0 #5c3a21;
        }

        .menu-btn {
            font-family: 'Noto Sans TC', sans-serif;
            font-size: 1.5rem;
            padding: 15px 40px;
            margin: 10px;
            width: 280px;
            background: #5c3a21; /* æœ¨é ­è‰² */
            border: 3px solid #8b5a2b;
            color: #f0e68c;
            cursor: pointer;
            border-radius: 10px;
            transition: transform 0.1s;
            box-shadow: 0 5px 10px rgba(0,0,0,0.5);
        }

        .menu-btn:hover { transform: scale(1.05); background: #6d4c33; }
        .menu-btn:active { transform: scale(0.95); }

        .instruction-box {
            background: rgba(92, 58, 33, 0.9);
            padding: 20px 30px;
            border-radius: 15px;
            border: 2px solid #8b5a2b;
            margin-top: 20px;
            max-width: 600px;
            color: #f0e68c;
            font-family: 'Noto Sans TC', sans-serif;
            font-size: 1.1rem;
            line-height: 1.6;
        }
        
        .highlight { color: #00ff00; font-weight: bold; }
        .safe { color: #87CEEB; font-weight: bold; }
        .bad { color: #ff4444; font-weight: bold; }

    </style>
    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="crosshair"></div>

    <div id="ui-layer">
        <div id="score-display">åˆ†æ•¸: <span id="score-val">0</span></div>
        <div id="level-display">é—œå¡: <span id="level-val">1</span></div>
        <div id="best-score-display">æœ€é«˜åˆ†: <span id="best-val">0</span></div>
        <div id="lives-display">â¤ï¸ <span id="lives-val">3</span></div>
        <div id="message-display">HEADSHOT!</div>
    </div>

    <!-- Main Menu -->
    <div id="start-screen" class="screen">
        <h1>æ£®æ—æ•¸å­¸çµäºº<br><span style="font-size: 1.5rem; color: #fff;">Crossbow Edition</span></h1>
        
        <button class="menu-btn" onclick="gameApp.startGame()">é–‹å§‹ç‹©çµ</button>
        
        <div class="instruction-box">
            <h3>ğŸ¹ åå­—å¼“çµäººæŒ‡å—</h3>
            <ul>
                <li><strong>ä»»å‹™ï¼š</strong>æ‰‹æŒYå‹åå­—å¼“ï¼Œè¾¨è­˜æ£®æ—ä¸­çš„æ•¸å­—å‹•ç‰©ã€‚</li>
                <li><strong>è¦å‰‡ï¼š</strong>
                    <ul>
                        <li><span class="highlight">è³ªæ•¸ (2, 3, 5, 7...)</span>ï¼šå¿…é ˆç‹©çµï¼(å°„æ“Šå¾—åˆ†)</li>
                        <li><span class="safe">éè³ªæ•¸ (4, 6, 8, 9...)</span>ï¼šè®“ç‰ é€šéï¼(ä¸è¦å°„æ“Šï¼Œå®‰å…¨)</li>
                    </ul>
                </li>
                <li><strong>æ‰£è¡€/å¤±æ•—æ¢ä»¶ï¼š</strong>
                    <ul>
                        <li><span class="bad">æ¼æ‰è³ªæ•¸</span>ï¼šè®“è³ªæ•¸å‹•ç‰©è¡åˆ°é¢å‰ (ä»»å‹™å¤±æ•—æ‰£è¡€)</li>
                        <li><span class="bad">æ¿«æ®ºç„¡è¾œ</span>ï¼šå°„ä¸­éè³ªæ•¸ (æ‰£åˆ†)</li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="color: #ff4444;">ç‹©çµçµæŸ</h1>
        <h2 style="color:white; font-size: 2.5rem;">æœ€çµ‚åˆ†æ•¸: <span id="final-score">0</span></h2>
        <button class="menu-btn" onclick="gameApp.restartGame()">å†æ¬¡æŒ‘æˆ°</button>
        <button class="menu-btn" onclick="gameApp.showMenu()">å›ä¸»é¸å–®</button>
    </div>

<script type="module">
import * as THREE from 'three';

// è³ªæ•¸è¡¨å¿«å–
function isPrime(num) {
    if (num <= 1) return false;
    if (num <= 3) return true;
    if (num % 2 === 0 || num % 3 === 0) return false;
    for (let i = 5; i * i <= num; i += 6) {
        if (num % i === 0 || num % (i + 2) === 0) return false;
    }
    return true;
}

// éŸ³æ•ˆç®¡ç†
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.4;
        this.masterGain.connect(this.ctx.destination);
    }

    playShoot() {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        // åå­—å¼“çš„è²éŸ³æ¯”è¼ƒçŸ­ä¿ƒæœ‰åŠ›
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(800, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
        
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.15);
    }

    playHit() {
        if (this.ctx.state === 'suspended') return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.2);
    }

    playCorrect() {
        if (this.ctx.state === 'suspended') return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(523.25, this.ctx.currentTime); // C5
        osc.frequency.setValueAtTime(783.99, this.ctx.currentTime + 0.1); // G5
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
    }
    
    playWrong() {
        if (this.ctx.state === 'suspended') return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 0.2);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
    }
}

// ç©å®¶çš„åå­—å¼“
class Crossbow {
    constructor(scene, camera) {
        this.scene = scene;
        this.camera = camera;
        this.group = new THREE.Group();
        
        // æè³ª
        const woodMat = new THREE.MeshPhongMaterial({ color: 0x5D4037 }); // æ·±æœ¨è‰²
        const metalMat = new THREE.MeshPhongMaterial({ color: 0x607D8B, shininess: 100 }); // é‡‘å±¬è‰²
        const stringMat = new THREE.LineBasicMaterial({ color: 0xEEEEEE });

        // 1. æ§æ‰˜ (Stock)
        const stockGeo = new THREE.BoxGeometry(0.15, 0.1, 0.8);
        const stock = new THREE.Mesh(stockGeo, woodMat);
        stock.position.z = 0.2;
        this.group.add(stock);
        
        // 2. å¼“è‡‚ (Limbs) - Yå­—å½¢
        const limbGeo = new THREE.BoxGeometry(0.08, 0.05, 0.6);
        const leftLimb = new THREE.Mesh(limbGeo, woodMat);
        leftLimb.position.set(-0.25, 0, -0.2);
        leftLimb.rotation.y = -Math.PI / 4; // Y shape left
        this.group.add(leftLimb);

        const rightLimb = new THREE.Mesh(limbGeo, woodMat);
        rightLimb.position.set(0.25, 0, -0.2);
        rightLimb.rotation.y = Math.PI / 4; // Y shape right
        this.group.add(rightLimb);

        // 3. å¼¦ (String)
        const points = [
            new THREE.Vector3(-0.45, 0, -0.4), // Left tip
            new THREE.Vector3(0, 0, 0.4),      // Trigger point
            new THREE.Vector3(0.45, 0, -0.4)   // Right tip
        ];
        const stringGeo = new THREE.BufferGeometry().setFromPoints(points);
        this.stringLine = new THREE.Line(stringGeo, stringMat);
        this.group.add(this.stringLine);

        // 4. ç„æº–å™¨/è»Œé“
        const railGeo = new THREE.BoxGeometry(0.05, 0.02, 0.8);
        const rail = new THREE.Mesh(railGeo, metalMat);
        rail.position.y = 0.06;
        stock.add(rail);

        // è¨­ç½®åˆ°å ´æ™¯ä¸­
        this.scene.add(this.group);
        
        this.isFiring = false;
        this.fireTime = 0;
    }

    update(mouse, time) {
        // å‘¼å¸æ•ˆæœ
        const breathe = Math.sin(time * 1.5) * 0.003;
        
        // è·Ÿéš¨æ»‘é¼ ç§»å‹•
        const targetX = mouse.x * 0.6;
        const targetY = mouse.y * 0.6;
        
        // è½‰æ›åˆ°ç›¸æ©Ÿç©ºé–“ (æ¨¡æ“¬ç¬¬ä¸€äººç¨±æŒæ§)
        // ä½ç½®åœ¨å³ä¸‹æ–¹
        const vector = new THREE.Vector3(0.25 + targetX * 0.1, -0.25 + targetY * 0.1 + breathe, -0.5);
        vector.applyQuaternion(this.camera.quaternion);
        vector.add(this.camera.position);
        
        this.group.position.copy(vector);
        
        // æ—‹è½‰è·Ÿéš¨ç›¸æ©Ÿï¼Œä¸¦ç¨å¾®æŒ‡å‘æº–å¿ƒ
        this.group.quaternion.copy(this.camera.quaternion);
        // å¾®èª¿è§’åº¦è®“æ§å£å°æº–è¢å¹•ä¸­å¿ƒ
        this.group.rotateX(0.05); 
        this.group.rotateY(-0.05); 

        // ç™¼å°„å‹•ç•« (å¾Œåº§åŠ›)
        if (this.isFiring) {
            const progress = (time - this.fireTime) * 15;
            if (progress < 1) {
                // å¾Œåº§åŠ›
                this.group.translateZ(progress * 0.1);
            } else if (progress < 3) {
                // å›æ­¸
                this.group.translateZ(0.1 - (progress-1) * 0.05);
            } else {
                this.isFiring = false;
            }
        }
    }
    
    trigger() {
        this.isFiring = true;
        this.fireTime = performance.now() / 1000;
    }
}

// å¼©ç®­
class Bolt {
    constructor(scene, position, direction) {
        this.scene = scene;
        this.active = true;
        this.speed = 80; // å¼©ç®­é€Ÿåº¦æ¯”å¼“ç®­å¿«
        this.direction = direction.normalize();
        
        this.group = new THREE.Group();
        this.group.position.copy(position);
        
        // ç®­æ¡¿ (è¼ƒçŸ­)
        const shaftGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.4, 8);
        const shaftMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const shaft = new THREE.Mesh(shaftGeo, shaftMat);
        shaft.rotation.x = Math.PI / 2;
        this.group.add(shaft);
        
        // ç®­é ­
        const tipGeo = new THREE.ConeGeometry(0.03, 0.1, 8);
        const tipMat = new THREE.MeshPhongMaterial({ color: 0xC0C0C0 }); // Fixed: Silver hex code
        const tip = new THREE.Mesh(tipGeo, tipMat);
        tip.rotation.x = Math.PI / 2;
        tip.position.z = 0.25;
        this.group.add(tip);
        
        // å°¾ç¾½ (è¢å…‰è‰²æ–¹ä¾¿çœ‹è»Œè·¡)
        const fletchGeo = new THREE.BoxGeometry(0.005, 0.08, 0.1);
        const fletchMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const fletch = new THREE.Mesh(fletchGeo, fletchMat);
        fletch.position.z = -0.15;
        this.group.add(fletch);
        
        this.group.lookAt(this.group.position.clone().add(this.direction));
        this.scene.add(this.group);
    }

    update(dt) {
        if (!this.active) return;
        this.group.position.add(this.direction.clone().multiplyScalar(this.speed * dt));
        
        if (this.group.position.length() > 100) {
            this.destroy();
        }
    }

    destroy() {
        this.active = false;
        this.scene.remove(this.group);
    }
}

// å‹•ç‰©å·¥å» 
class Animal {
    constructor(scene, level) {
        this.scene = scene;
        this.active = true;
        this.group = new THREE.Group();
        
        this.number = Math.floor(Math.random() * 98) + 2;
        this.isPrime = isPrime(this.number);
        
        // å‹•ç‰©é¡å‹ï¼šé‡è±¬ã€å…”å­ã€ç‹ç‹¸ (ç„¡ä¿è‚²é¡)
        const types = ['boar', 'rabbit', 'fox'];
        this.type = types[Math.floor(Math.random() * types.length)];
        
        this.buildModel();
        
        // æ•¸å­—é¡¯ç¤º (Billboard)
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        // è³ªæ•¸ç”¨äº®ç¶ è‰²ï¼Œéè³ªæ•¸ç”¨ç™½è‰² (æˆ–ç¨å¾®ç°ä¸€é»)ï¼Œä¸è¦å¤ªæ˜é¡¯æç¤ºï¼Œè€ƒé©—å¿ƒç®—
        ctx.fillStyle = this.isPrime ? '#32CD32' : '#FFFFFF'; 
        ctx.font = 'bold 160px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 12;
        ctx.lineJoin = 'round';
        ctx.strokeText(this.number, 128, 128);
        ctx.fillText(this.number, 128, 128);
        
        const tex = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ map: tex });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.position.y = 2.0;
        sprite.scale.set(1.5, 1.5, 1);
        this.group.add(sprite);

        // ç”Ÿæˆä½ç½®
        const startZ = -40 - Math.random() * 20;
        const startX = (Math.random() - 0.5) * 25; // ç¯„åœå¤§ä¸€é»
        this.group.position.set(startX, 0, startZ);
        this.group.lookAt(0, 0, 0); 
        
        // é€Ÿåº¦
        const baseSpeed = this.type === 'rabbit' ? 8 : (this.type === 'fox' ? 7 : 5);
        this.speed = baseSpeed + (level * 0.6); 
        this.animTime = Math.random();
        
        this.scene.add(this.group);
    }

    buildModel() {
        let mainColor;
        
        if (this.type === 'boar') {
            // --- é‡è±¬ (æ·±æ£•è‰²) ---
            mainColor = 0x5D4037;
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1, 1.8), new THREE.MeshPhongMaterial({color: mainColor}));
            body.position.y = 0.8;
            this.group.add(body);
            
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 1), new THREE.MeshPhongMaterial({color: mainColor}));
            head.position.set(0, 1.0, 1.2);
            this.group.add(head);
            
            const tusk = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.3, 8), new THREE.MeshPhongMaterial({color: 0xffffff}));
            tusk.rotation.x = Math.PI/4;
            tusk.position.set(0.25, 0.8, 1.6);
            this.group.add(tusk);
            
            // è…¿
            const legGeo = new THREE.BoxGeometry(0.2, 0.6, 0.2);
            [[0.4, 0.3, 0.6], [-0.4, 0.3, 0.6], [0.4, 0.3, -0.6], [-0.4, 0.3, -0.6]].forEach(pos => {
                const leg = new THREE.Mesh(legGeo, new THREE.MeshPhongMaterial({color: mainColor}));
                leg.position.set(...pos);
                this.group.add(leg);
            });

        } else if (this.type === 'rabbit') {
            // --- é‡å…” (ç°ç™½è‰²) ---
            mainColor = 0xDCDCDC;
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), new THREE.MeshPhongMaterial({color: mainColor}));
            body.scale.set(1, 0.8, 1.2);
            body.position.y = 0.5;
            this.group.add(body);
            
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 16), new THREE.MeshPhongMaterial({color: mainColor}));
            head.position.set(0, 0.8, 0.6);
            this.group.add(head);
            
            // é•·è€³æœµ
            const earGeo = new THREE.CapsuleGeometry(0.08, 0.5, 4, 8);
            const ear1 = new THREE.Mesh(earGeo, new THREE.MeshPhongMaterial({color: mainColor}));
            ear1.position.set(0.15, 1.2, 0.5);
            ear1.rotation.x = -0.2;
            this.group.add(ear1);
            const ear2 = ear1.clone();
            ear2.position.set(-0.15, 1.2, 0.5);
            this.group.add(ear2);
            
            // å°å°¾å·´
            const tail = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshPhongMaterial({color: 0xffffff}));
            tail.position.set(0, 0.4, -0.6);
            this.group.add(tail);

        } else {
            // --- ç‹ç‹¸ (æ©˜è‰²) ---
            mainColor = 0xFF8C00; // DarkOrange
            const whiteMat = new THREE.MeshPhongMaterial({color: 0xFFFFFF});
            
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.6, 1.2), new THREE.MeshPhongMaterial({color: mainColor}));
            body.position.y = 0.6;
            this.group.add(body);
            
            const head = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 16), new THREE.MeshPhongMaterial({color: mainColor}));
            head.rotation.x = -Math.PI/2;
            head.position.set(0, 1.0, 0.8);
            this.group.add(head);
            
            // å¤§å°¾å·´
            const tail = new THREE.Mesh(new THREE.CapsuleGeometry(0.2, 0.8, 4, 8), new THREE.MeshPhongMaterial({color: mainColor}));
            tail.rotation.x = Math.PI/3;
            tail.position.set(0, 0.8, -0.8);
            this.group.add(tail);
            const tailTip = new THREE.Mesh(new THREE.SphereGeometry(0.2), whiteMat);
            tailTip.position.set(0, 1.15, -1.05);
            this.group.add(tailTip);
        }
    }

    update(dt) {
        if (!this.active) return;
        
        // ç§»å‹•ï¼šè·‘å‘ (0,0,0)
        const dir = this.group.position.clone().negate().normalize(); 
        dir.y = 0;
        
        this.group.position.add(dir.multiplyScalar(this.speed * dt));
        this.group.lookAt(0, 0, 0); 
        
        // è·‘æ­¥å‹•ç•« (ä¸Šä¸‹è·³å‹•)
        this.animTime += dt * 12;
        const bounce = Math.abs(Math.sin(this.animTime)) * (this.type === 'rabbit' ? 0.4 : 0.15);
        this.group.position.y = bounce;

        // è·é›¢æª¢æ¸¬
        const dist = this.group.position.length();

        // åˆ°é”ç©å®¶é¢å‰ (Z ç´„ç‚º 0, å¯¦éš›ä¸Šé è¿‘ç›¸æ©Ÿ)
        if (dist < 3.0) {
            return "reached_player";
        }
        return "running";
    }

    destroy() {
        this.active = false;
        this.scene.remove(this.group);
    }
}

class GameApp {
    constructor() {
        this.initThree();
        this.clock = new THREE.Clock();
        this.audio = new SoundManager();
        
        this.crossbow = new Crossbow(this.scene, this.camera);
        
        this.bolts = [];
        this.animals = [];
        
        this.score = 0;
        this.lives = 3;
        this.level = 1;
        this.bestScore = localStorage.getItem('mathHunterBest') || 0;
        this.spawnTimer = 0;
        
        this.mouse = new THREE.Vector2();
        this.raycaster = new THREE.Raycaster();

        this.ui = {
            score: document.getElementById('score-val'),
            level: document.getElementById('level-val'),
            best: document.getElementById('best-val'),
            lives: document.getElementById('lives-val'),
            message: document.getElementById('message-display'),
            startScreen: document.getElementById('start-screen'),
            gameOverScreen: document.getElementById('game-over-screen'),
            finalScore: document.getElementById('final-score')
        };
        
        this.setupInput();
        this.updateUI();
        this.animate();
    }

    initThree() {
        this.container = document.getElementById('canvas-container');
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.Fog(0x87CEEB, 15, 50);
        
        // åœ°æ¿
        const groundGeo = new THREE.PlaneGeometry(200, 200);
        const groundMat = new THREE.MeshPhongMaterial({ color: 0x4CAF50 }); 
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        this.scene.add(ground);
        
        // æ¨¹æœ¨ (è£é£¾)
        for(let i=0; i<30; i++) {
            const tree = new THREE.Group();
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.6, 3), 
                new THREE.MeshPhongMaterial({color: 0x795548})
            );
            trunk.position.y = 1.5;
            
            const leaves = new THREE.Mesh(
                new THREE.ConeGeometry(2.5, 5, 8),
                new THREE.MeshPhongMaterial({color: 0x2E7D32})
            );
            leaves.position.y = 4;
            
            tree.add(trunk);
            tree.add(leaves);
            
            const angle = Math.random() * Math.PI * 2;
            const dist = 25 + Math.random() * 40;
            tree.position.set(Math.cos(angle)*dist, 0, Math.sin(angle)*dist);
            this.scene.add(tree);
        }

        // Camera
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        this.camera.position.set(0, 1.6, 0); 
        this.camera.lookAt(0, 1.6, -10);

        // Renderer
        this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.container.appendChild(this.renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        this.scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 15, 10);
        this.scene.add(dirLight);
    }

    setupInput() {
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });

        const handleMove = (x, y) => {
            this.mouse.x = (x / window.innerWidth) * 2 - 1;
            this.mouse.y = -(y / window.innerHeight) * 2 + 1;
        };

        const handleShoot = () => {
            if (this.mode !== 'playing') return;
            
            this.audio.playShoot();
            this.crossbow.trigger();
            
            // è¨ˆç®—å°„æ“Šæ–¹å‘
            this.raycaster.setFromCamera(this.mouse, this.camera);
            const direction = this.raycaster.ray.direction.clone();
            
            // å¼©ç®­èµ·é»
            const startPos = this.camera.position.clone().add(direction.multiplyScalar(0.5));
            startPos.y -= 0.1;
            
            this.bolts.push(new Bolt(this.scene, startPos, this.raycaster.ray.direction));
        };

        document.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        document.addEventListener('mousedown', handleShoot);
        
        // Touch
        this.container.addEventListener('touchmove', e => {
            e.preventDefault();
            handleMove(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        this.container.addEventListener('touchstart', e => {
            e.preventDefault();
            handleMove(e.touches[0].clientX, e.touches[0].clientY);
            handleShoot();
        }, {passive: false});
    }

    startGame() {
        this.mode = 'playing';
        this.score = 0;
        this.lives = 3;
        this.level = 1;
        this.spawnTimer = 0;
        
        this.animals.forEach(a => a.destroy());
        this.bolts.forEach(b => b.destroy());
        this.animals = [];
        this.bolts = [];

        this.ui.startScreen.classList.add('hidden');
        this.ui.gameOverScreen.classList.add('hidden');
        this.updateUI();
    }
    
    showMenu() {
        this.mode = 'menu';
        this.ui.startScreen.classList.remove('hidden');
        this.ui.gameOverScreen.classList.add('hidden');
    }

    restartGame() {
        this.startGame();
    }

    showMessage(text, color) {
        const el = this.ui.message;
        el.innerText = text;
        el.style.color = color;
        el.style.opacity = 1;
        el.style.top = '30%';
        
        setTimeout(() => {
            el.style.top = '25%';
            el.style.opacity = 0;
        }, 800);
    }

    checkCollisions() {
        for (let i = this.bolts.length - 1; i >= 0; i--) {
            const bolt = this.bolts[i];
            let hit = false;
            
            for (let j = this.animals.length - 1; j >= 0; j--) {
                const animal = this.animals[j];
                const dist = bolt.group.position.distanceTo(animal.group.position);
                
                // ç¢°æ’åˆ¤å®š
                if (dist < 1.8) {
                    this.handleHit(animal);
                    animal.destroy();
                    this.animals.splice(j, 1);
                    hit = true;
                    break;
                }
            }
            
            if (hit) {
                bolt.destroy();
                this.bolts.splice(i, 1);
            }
        }
    }

    handleHit(animal) {
        if (animal.isPrime) {
            // æ­£ç¢ºå°„ä¸­è³ªæ•¸ -> åŠ åˆ†
            this.score += 10;
            this.audio.playCorrect();
            this.showMessage(`ç‹©çµæˆåŠŸ! ${animal.number}`, '#00ff00');
            
            if (Math.floor(this.score / 100) + 1 > this.level) {
                this.level++;
                this.showMessage(`LEVEL UP! ${this.level}`, '#00ffff');
            }
        } else {
            // å°„ä¸­éè³ªæ•¸ -> æ¿«æ®ºç„¡è¾œï¼Œæ‰£åˆ† (ä¸æ‰£è¡€ï¼Œä½†æ‰£åˆ†ä½œç‚ºæ‡²ç½°)
            this.score = Math.max(0, this.score - 5);
            this.audio.playWrong();
            this.showMessage(`ä¸è¦å°„éè³ªæ•¸! -5`, '#FFA500');
        }
        this.updateUI();
    }
    
    handleAnimalReachPlayer(animal) {
        if (animal.isPrime) {
            // è³ªæ•¸è·‘æ‰äº† -> ä»»å‹™å¤±æ•— (æ¼æ‰çµç‰©)ï¼Œæ‰£è¡€
            this.lives--;
            this.audio.playHit();
            this.renderer.domElement.style.filter = 'brightness(3) sepia(1) hue-rotate(-50deg)';
            setTimeout(() => { this.renderer.domElement.style.filter = 'none'; }, 100);
            
            this.showMessage(`æ¼æ‰çµç‰©! ${animal.number}`, '#ff0000');
            if (this.lives <= 0) this.gameOver();
        } else {
            // éè³ªæ•¸è·‘æ‰äº† -> å®‰å…¨é€šéï¼Œæ²’äº‹
            // å¯ä»¥åŠ ä¸€é»éŸ³æ•ˆè¡¨ç¤º"å®‰å…¨"
            this.showMessage(`å®‰å…¨é€šé`, '#87CEEB');
        }
        this.updateUI();
    }

    gameOver() {
        this.mode = 'gameover';
        if (this.score > this.bestScore) {
            this.bestScore = this.score;
            localStorage.setItem('mathHunterBest', this.bestScore);
        }
        this.ui.finalScore.innerText = this.score;
        this.ui.gameOverScreen.classList.remove('hidden');
        this.updateUI();
    }

    updateUI() {
        this.ui.score.innerText = this.score;
        this.ui.level.innerText = this.level;
        this.ui.best.innerText = this.bestScore;
        this.ui.lives.innerText = this.lives;
    }

    animate() {
        requestAnimationFrame(this.animate.bind(this));
        
        const dt = Math.min(this.clock.getDelta(), 0.1);
        const time = this.clock.getElapsedTime();
        
        this.crossbow.update(this.mouse, time);

        if (this.mode === 'playing') {
            this.spawnTimer -= dt;

            if (this.spawnTimer <= 0) {
                this.animals.push(new Animal(this.scene, this.level));
                const spawnInterval = Math.max(0.6, 2.0 - (this.level * 0.15));
                this.spawnTimer = spawnInterval;
            }

            for (let i = this.bolts.length - 1; i >= 0; i--) {
                this.bolts[i].update(dt);
                if (!this.bolts[i].active) this.bolts.splice(i, 1);
            }

            for (let i = this.animals.length - 1; i >= 0; i--) {
                const status = this.animals[i].update(dt);
                if (status === "reached_player") {
                    this.handleAnimalReachPlayer(this.animals[i]);
                    this.animals[i].destroy();
                    this.animals.splice(i, 1);
                }
            }

            this.checkCollisions();
        }

        this.renderer.render(this.scene, this.camera);
    }
}

window.gameApp = new GameApp();

</script>
</body>
</html>
